CVE ID,Vulnerable Code,Patched Code
binfmt_elf.c,"static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
{
 struct file *interpreter = NULL; /* to shut gcc up */
  unsigned long load_addr = 0, load_bias = 0;
 int load_addr_set = 0;
 char * elf_interpreter = NULL;
 unsigned int interpreter_type = INTERPRETER_NONE;
 unsigned char ibcs2_interpreter = 0;
 unsigned long error;
 struct elf_phdr *elf_ppnt, *elf_phdata;
 unsigned long elf_bss, elf_brk;
 int elf_exec_fileno;
 int retval, i;
 unsigned int size;
 unsigned long elf_entry, interp_load_addr = 0;
 unsigned long start_code, end_code, start_data, end_data;
 unsigned long reloc_func_desc = 0;
 char passed_fileno[6];
 struct files_struct *files;
 int executable_stack = EXSTACK_DEFAULT;
 unsigned long def_flags = 0;
 struct {
  struct elfhdr elf_ex;
  struct elfhdr interp_elf_ex;
    struct exec interp_ex;
 } *loc;

 loc = kmalloc(sizeof(*loc), GFP_KERNEL);
 if (!loc) {
  retval = -ENOMEM;
  goto out_ret;
 }
 
 /* Get the exec-header */
 loc->elf_ex = *((struct elfhdr *)bprm->buf);

 retval = -ENOEXEC;
 /* First of all, some simple consistency checks */
 if (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)
  goto out;

 if (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)
  goto out;
 if (!elf_check_arch(&loc->elf_ex))
  goto out;
 if (!bprm->file->f_op||!bprm->file->f_op->mmap)
  goto out;

 /* Now read in all of the header information */
 if (loc->elf_ex.e_phentsize != sizeof(struct elf_phdr))
  goto out;
 if (loc->elf_ex.e_phnum < 1 ||
   loc->elf_ex.e_phnum > 65536U / sizeof(struct elf_phdr))
  goto out;
 size = loc->elf_ex.e_phnum * sizeof(struct elf_phdr);
 retval = -ENOMEM;
 elf_phdata = kmalloc(size, GFP_KERNEL);
 if (!elf_phdata)
  goto out;

 retval = kernel_read(bprm->file, loc->elf_ex.e_phoff,
        (char *)elf_phdata, size);
 if (retval != size) {
  if (retval >= 0)
   retval = -EIO;
  goto out_free_ph;
 }

 files = current->files; /* Refcounted so ok */
 retval = unshare_files();
 if (retval < 0)
  goto out_free_ph;
 if (files == current->files) {
  put_files_struct(files);
  files = NULL;
 }

 /* exec will make our files private anyway, but for the a.out
    loader stuff we need to do it earlier */
 retval = get_unused_fd();
 if (retval < 0)
  goto out_free_fh;
 get_file(bprm->file);
 fd_install(elf_exec_fileno = retval, bprm->file);

 elf_ppnt = elf_phdata;
 elf_bss = 0;
 elf_brk = 0;

 start_code = ~0UL;
 end_code = 0;
 start_data = 0;
 end_data = 0;

 for (i = 0; i < loc->elf_ex.e_phnum; i++) {
  if (elf_ppnt->p_type == PT_INTERP) {
   /* This is the program interpreter used for
    * shared libraries - for now assume that this
    * is an a.out format binary
    */
   retval = -ENOEXEC;
   if (elf_ppnt->p_filesz > PATH_MAX || 
       elf_ppnt->p_filesz < 2)
    goto out_free_file;

   retval = -ENOMEM;
   elf_interpreter = kmalloc(elf_ppnt->p_filesz,
        GFP_KERNEL);
   if (!elf_interpreter)
    goto out_free_file;

   retval = kernel_read(bprm->file, elf_ppnt->p_offset,
          elf_interpreter,
          elf_ppnt->p_filesz);
   if (retval != elf_ppnt->p_filesz) {
    if (retval >= 0)
     retval = -EIO;
    goto out_free_interp;
   }
   /* make sure path is NULL terminated */
   retval = -ENOEXEC;
   if (elf_interpreter[elf_ppnt->p_filesz - 1] != '\0')
    goto out_free_interp;

   /* If the program interpreter is one of these two,
    * then assume an iBCS2 image. Otherwise assume
    * a native linux image.
    */
   if (strcmp(elf_interpreter,""/usr/lib/libc.so.1"") == 0 ||
       strcmp(elf_interpreter,""/usr/lib/ld.so.1"") == 0)
    ibcs2_interpreter = 1;

   /*
    * The early SET_PERSONALITY here is so that the lookup
    * for the interpreter happens in the namespace of the 
    * to-be-execed image.  SET_PERSONALITY can select an
    * alternate root.
    *
    * However, SET_PERSONALITY is NOT allowed to switch
    * this task into the new images's memory mapping
    * policy - that is, TASK_SIZE must still evaluate to
    * that which is appropriate to the execing application.
    * This is because exit_mmap() needs to have TASK_SIZE
    * evaluate to the size of the old image.
    *
    * So if (say) a 64-bit application is execing a 32-bit
    * application it is the architecture's responsibility
    * to defer changing the value of TASK_SIZE until the
    * switch really is going to happen - do this in
    * flush_thread(). - akpm
    */
   SET_PERSONALITY(loc->elf_ex, ibcs2_interpreter);

   interpreter = open_exec(elf_interpreter);
   retval = PTR_ERR(interpreter);
   if (IS_ERR(interpreter))
    goto out_free_interp;
   retval = kernel_read(interpreter, 0, bprm->buf,
          BINPRM_BUF_SIZE);
   if (retval != BINPRM_BUF_SIZE) {
    if (retval >= 0)
     retval = -EIO;
    goto out_free_dentry;
   }

   /* Get the exec headers */
   loc->interp_ex = *((struct exec *)bprm->buf);
   loc->interp_elf_ex = *((struct elfhdr *)bprm->buf);
   break;
  }
  elf_ppnt++;
 }

 elf_ppnt = elf_phdata;
 for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)
  if (elf_ppnt->p_type == PT_GNU_STACK) {
   if (elf_ppnt->p_flags & PF_X)
    executable_stack = EXSTACK_ENABLE_X;
   else
    executable_stack = EXSTACK_DISABLE_X;
   break;
  }

 /* Some simple consistency checks for the interpreter */
 if (elf_interpreter) {
  interpreter_type = INTERPRETER_ELF | INTERPRETER_AOUT;

  /* Now figure out which format our binary is */
  if ((N_MAGIC(loc->interp_ex) != OMAGIC) &&
      (N_MAGIC(loc->interp_ex) != ZMAGIC) &&
      (N_MAGIC(loc->interp_ex) != QMAGIC))
   interpreter_type = INTERPRETER_ELF;

  if (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)
   interpreter_type &= ~INTERPRETER_ELF;

  retval = -ELIBBAD;
  if (!interpreter_type)
   goto out_free_dentry;

  /* Make sure only one type was selected */
  if ((interpreter_type & INTERPRETER_ELF) &&
       interpreter_type != INTERPRETER_ELF) {
        // FIXME - ratelimit this before re-enabling
   // printk(KERN_WARNING ""ELF: Ambiguous type, using ELF\n"");
   interpreter_type = INTERPRETER_ELF;
  }
  /* Verify the interpreter has a valid arch */
  if ((interpreter_type == INTERPRETER_ELF) &&
      !elf_check_arch(&loc->interp_elf_ex))
   goto out_free_dentry;
 } else {
  /* Executables without an interpreter also need a personality  */
  SET_PERSONALITY(loc->elf_ex, ibcs2_interpreter);
 }

 /* OK, we are done with that, now set up the arg stuff,
    and then start this sucker up */
 if ((!bprm->sh_bang) && (interpreter_type == INTERPRETER_AOUT)) {
  char *passed_p = passed_fileno;
  sprintf(passed_fileno, ""%d"", elf_exec_fileno);

  if (elf_interpreter) {
   retval = copy_strings_kernel(1, &passed_p, bprm);
   if (retval)
    goto out_free_dentry; 
   bprm->argc++;
  }
 }

 /* Flush all traces of the currently running executable */
 retval = flush_old_exec(bprm);
 if (retval)
  goto out_free_dentry;

 /* Discard our unneeded old files struct */
 if (files) {
  put_files_struct(files);
  files = NULL;
 }

 /* OK, This is the point of no return */
 current->mm->start_data = 0;
 current->mm->end_data = 0;
 current->mm->end_code = 0;
 current->mm->mmap = NULL;
 current->flags &= ~PF_FORKNOEXEC;
 current->mm->def_flags = def_flags;

 /* Do this immediately, since STACK_TOP as used in setup_arg_pages
    may depend on the personality.  */
 SET_PERSONALITY(loc->elf_ex, ibcs2_interpreter);
 if (elf_read_implies_exec(loc->elf_ex, executable_stack))
  current->personality |= READ_IMPLIES_EXEC;

 if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
  current->flags |= PF_RANDOMIZE;
 arch_pick_mmap_layout(current->mm);

 /* Do this so that we can load the interpreter, if need be.  We will
    change some of these later */
 current->mm->free_area_cache = current->mm->mmap_base;
 current->mm->cached_hole_size = 0;
 retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),
     executable_stack);
 if (retval < 0) {
  send_sig(SIGKILL, current, 0);
  goto out_free_dentry;
 }
 
 current->mm->start_stack = bprm->p;

 /* Now we do a little grungy work by mmaping the ELF image into
    the correct location in memory.  At this point, we assume that
    the image should be loaded at fixed address, not at a variable
    address. */
 for(i = 0, elf_ppnt = elf_phdata;
     i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {
  int elf_prot = 0, elf_flags;
  unsigned long k, vaddr;

  if (elf_ppnt->p_type != PT_LOAD)
   continue;

  if (unlikely (elf_brk > elf_bss)) {
   unsigned long nbyte;
             
   /* There was a PT_LOAD segment with p_memsz > p_filesz
      before this one. Map anonymous pages, if needed,
      and clear the area.  */
   retval = set_brk (elf_bss + load_bias,
       elf_brk + load_bias);
   if (retval) {
    send_sig(SIGKILL, current, 0);
    goto out_free_dentry;
   }
   nbyte = ELF_PAGEOFFSET(elf_bss);
   if (nbyte) {
    nbyte = ELF_MIN_ALIGN - nbyte;
    if (nbyte > elf_brk - elf_bss)
     nbyte = elf_brk - elf_bss;
    if (clear_user((void __user *)elf_bss +
       load_bias, nbyte)) {
     /*
      * This bss-zeroing can fail if the ELF
      * file specifies odd protections. So
      * we don't check the return value
      */
    }
   }
  }

  if (elf_ppnt->p_flags & PF_R)
   elf_prot |= PROT_READ;
  if (elf_ppnt->p_flags & PF_W)
   elf_prot |= PROT_WRITE;
  if (elf_ppnt->p_flags & PF_X)
   elf_prot |= PROT_EXEC;

  elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;

  vaddr = elf_ppnt->p_vaddr;
  if (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {
   elf_flags |= MAP_FIXED;
  } else if (loc->elf_ex.e_type == ET_DYN) {
   /* Try and get dynamic programs out of the way of the
    * default mmap base, as well as whatever program they
    * might try to exec.  This is because the brk will
    * follow the loader, and is not movable.  */
   load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
  }

  error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,
    elf_prot, elf_flags);
  if (BAD_ADDR(error)) {
   send_sig(SIGKILL, current, 0);
   goto out_free_dentry;
  }

  if (!load_addr_set) {
   load_addr_set = 1;
   load_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);
   if (loc->elf_ex.e_type == ET_DYN) {
    load_bias += error -
                 ELF_PAGESTART(load_bias + vaddr);
    load_addr += load_bias;
    reloc_func_desc = load_bias;
   }
  }
  k = elf_ppnt->p_vaddr;
  if (k < start_code)
   start_code = k;
  if (start_data < k)
   start_data = k;

  /*
   * Check to see if the section's size will overflow the
   * allowed task size. Note that p_filesz must always be
   * <= p_memsz so it is only necessary to check p_memsz.
   */
  if (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||
      elf_ppnt->p_memsz > TASK_SIZE ||
      TASK_SIZE - elf_ppnt->p_memsz < k) {
   /* set_brk can never work. Avoid overflows. */
   send_sig(SIGKILL, current, 0);
   goto out_free_dentry;
  }

  k = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;

  if (k > elf_bss)
   elf_bss = k;
  if ((elf_ppnt->p_flags & PF_X) && end_code < k)
   end_code = k;
  if (end_data < k)
   end_data = k;
  k = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;
  if (k > elf_brk)
   elf_brk = k;
 }

 loc->elf_ex.e_entry += load_bias;
 elf_bss += load_bias;
 elf_brk += load_bias;
 start_code += load_bias;
 end_code += load_bias;
 start_data += load_bias;
 end_data += load_bias;

 /* Calling set_brk effectively mmaps the pages that we need
  * for the bss and break sections.  We must do this before
  * mapping in the interpreter, to make sure it doesn't wind
  * up getting placed where the bss needs to go.
  */
 retval = set_brk(elf_bss, elf_brk);
 if (retval) {
  send_sig(SIGKILL, current, 0);
  goto out_free_dentry;
 }
 if (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {
  send_sig(SIGSEGV, current, 0);
  retval = -EFAULT; /* Nobody gets to see this, but.. */
  goto out_free_dentry;
 }

 if (elf_interpreter) {
  if (interpreter_type == INTERPRETER_AOUT)
   elf_entry = load_aout_interp(&loc->interp_ex,
           interpreter);
  else
   elf_entry = load_elf_interp(&loc->interp_elf_ex,
          interpreter,
          &interp_load_addr);
  if (BAD_ADDR(elf_entry)) {
   force_sig(SIGSEGV, current);
   retval = IS_ERR((void *)elf_entry) ?
     (int)elf_entry : -EINVAL;
   goto out_free_dentry;
  }
  reloc_func_desc = interp_load_addr;

  allow_write_access(interpreter);
  fput(interpreter);
  kfree(elf_interpreter);
 } else {
  elf_entry = loc->elf_ex.e_entry;
  if (BAD_ADDR(elf_entry)) {
   force_sig(SIGSEGV, current);
   retval = -EINVAL;
   goto out_free_dentry;
  }
 }

 kfree(elf_phdata);

 if (interpreter_type != INTERPRETER_AOUT)
  sys_close(elf_exec_fileno);

 set_binfmt(&elf_format);

#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES
 retval = arch_setup_additional_pages(bprm, executable_stack);
 if (retval < 0) {
  send_sig(SIGKILL, current, 0);
  goto out;
 }
#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */

 compute_creds(bprm);
 current->flags &= ~PF_FORKNOEXEC;
 create_elf_tables(bprm, &loc->elf_ex,
     (interpreter_type == INTERPRETER_AOUT),
     load_addr, interp_load_addr);
 /* N.B. passed_fileno might not be initialized? */
 if (interpreter_type == INTERPRETER_AOUT)
  current->mm->arg_start += strlen(passed_fileno) + 1;
 current->mm->end_code = end_code;
 current->mm->start_code = start_code;
 current->mm->start_data = start_data;
 current->mm->end_data = end_data;
 current->mm->start_stack = bprm->p;

 if (current->personality & MMAP_PAGE_ZERO) {
  /* Why this, you ask???  Well SVr4 maps page 0 as read-only,
     and some applications ""depend"" upon this behavior.
     Since we do not have the power to recompile these, we
     emulate the SVr4 behavior. Sigh. */
  down_write(&current->mm->mmap_sem);
  error = do_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,
    MAP_FIXED | MAP_PRIVATE, 0);
  up_write(&current->mm->mmap_sem);
 }

#ifdef ELF_PLAT_INIT
 /*
  * The ABI may specify that certain registers be set up in special
  * ways (on i386 %edx is the address of a DT_FINI function, for
  * example.  In addition, it may also specify (eg, PowerPC64 ELF)
  * that the e_entry field is the address of the function descriptor
  * for the startup routine, rather than the address of the startup
  * routine itself.  This macro performs whatever initialization to
  * the regs structure is required as well as any relocations to the
  * function descriptor entries when executing dynamically links apps.
  */
 ELF_PLAT_INIT(regs, reloc_func_desc);
#endif

 start_thread(regs, elf_entry, bprm->p);
 if (unlikely(current->ptrace & PT_PTRACED)) {
  if (current->ptrace & PT_TRACE_EXEC)
   ptrace_notify ((PTRACE_EVENT_EXEC << 8) | SIGTRAP);
  else
   send_sig(SIGTRAP, current, 0);
 }
 retval = 0;
out:
 kfree(loc);
out_ret:
 return retval;

 /* error cleanup */
out_free_dentry:
 allow_write_access(interpreter);
 if (interpreter)
  fput(interpreter);
out_free_interp:
 kfree(elf_interpreter);
out_free_file:
 sys_close(elf_exec_fileno);
out_free_fh:
 if (files)
  reset_files_struct(current, files);
out_free_ph:
 kfree(elf_phdata);
 goto out;
}
","static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
{
 struct file *interpreter = NULL; /* to shut gcc up */
  unsigned long load_addr = 0, load_bias = 0;
 int load_addr_set = 0;
 char * elf_interpreter = NULL;
 unsigned int interpreter_type = INTERPRETER_NONE;
 unsigned char ibcs2_interpreter = 0;
 unsigned long error;
 struct elf_phdr *elf_ppnt, *elf_phdata;
 unsigned long elf_bss, elf_brk;
 int elf_exec_fileno;
 int retval, i;
 unsigned int size;
 unsigned long elf_entry, interp_load_addr = 0;
 unsigned long start_code, end_code, start_data, end_data;
 unsigned long reloc_func_desc = 0;
 char passed_fileno[6];
 struct files_struct *files;
 int executable_stack = EXSTACK_DEFAULT;
 unsigned long def_flags = 0;
 struct {
  struct elfhdr elf_ex;
  struct elfhdr interp_elf_ex;
    struct exec interp_ex;
 } *loc;

 loc = kmalloc(sizeof(*loc), GFP_KERNEL);
 if (!loc) {
  retval = -ENOMEM;
  goto out_ret;
 }
 
 /* Get the exec-header */
 loc->elf_ex = *((struct elfhdr *)bprm->buf);

 retval = -ENOEXEC;
 /* First of all, some simple consistency checks */
 if (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)
  goto out;

 if (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)
  goto out;
 if (!elf_check_arch(&loc->elf_ex))
  goto out;
 if (!bprm->file->f_op||!bprm->file->f_op->mmap)
  goto out;

 /* Now read in all of the header information */
 if (loc->elf_ex.e_phentsize != sizeof(struct elf_phdr))
  goto out;
 if (loc->elf_ex.e_phnum < 1 ||
   loc->elf_ex.e_phnum > 65536U / sizeof(struct elf_phdr))
  goto out;
 size = loc->elf_ex.e_phnum * sizeof(struct elf_phdr);
 retval = -ENOMEM;
 elf_phdata = kmalloc(size, GFP_KERNEL);
 if (!elf_phdata)
  goto out;

 retval = kernel_read(bprm->file, loc->elf_ex.e_phoff,
        (char *)elf_phdata, size);
 if (retval != size) {
  if (retval >= 0)
   retval = -EIO;
  goto out_free_ph;
 }

 files = current->files; /* Refcounted so ok */
 retval = unshare_files();
 if (retval < 0)
  goto out_free_ph;
 if (files == current->files) {
  put_files_struct(files);
  files = NULL;
 }

 /* exec will make our files private anyway, but for the a.out
    loader stuff we need to do it earlier */
 retval = get_unused_fd();
 if (retval < 0)
  goto out_free_fh;
 get_file(bprm->file);
 fd_install(elf_exec_fileno = retval, bprm->file);

 elf_ppnt = elf_phdata;
 elf_bss = 0;
 elf_brk = 0;

 start_code = ~0UL;
 end_code = 0;
 start_data = 0;
 end_data = 0;

 for (i = 0; i < loc->elf_ex.e_phnum; i++) {
  if (elf_ppnt->p_type == PT_INTERP) {
   /* This is the program interpreter used for
    * shared libraries - for now assume that this
    * is an a.out format binary
    */
   retval = -ENOEXEC;
   if (elf_ppnt->p_filesz > PATH_MAX || 
       elf_ppnt->p_filesz < 2)
    goto out_free_file;

   retval = -ENOMEM;
   elf_interpreter = kmalloc(elf_ppnt->p_filesz,
        GFP_KERNEL);
   if (!elf_interpreter)
    goto out_free_file;

   retval = kernel_read(bprm->file, elf_ppnt->p_offset,
          elf_interpreter,
          elf_ppnt->p_filesz);
   if (retval != elf_ppnt->p_filesz) {
    if (retval >= 0)
     retval = -EIO;
    goto out_free_interp;
   }
   /* make sure path is NULL terminated */
   retval = -ENOEXEC;
   if (elf_interpreter[elf_ppnt->p_filesz - 1] != '\0')
    goto out_free_interp;

   /* If the program interpreter is one of these two,
    * then assume an iBCS2 image. Otherwise assume
    * a native linux image.
    */
   if (strcmp(elf_interpreter,""/usr/lib/libc.so.1"") == 0 ||
       strcmp(elf_interpreter,""/usr/lib/ld.so.1"") == 0)
    ibcs2_interpreter = 1;

   /*
    * The early SET_PERSONALITY here is so that the lookup
    * for the interpreter happens in the namespace of the 
    * to-be-execed image.  SET_PERSONALITY can select an
    * alternate root.
    *
    * However, SET_PERSONALITY is NOT allowed to switch
    * this task into the new images's memory mapping
    * policy - that is, TASK_SIZE must still evaluate to
    * that which is appropriate to the execing application.
    * This is because exit_mmap() needs to have TASK_SIZE
    * evaluate to the size of the old image.
    *
    * So if (say) a 64-bit application is execing a 32-bit
    * application it is the architecture's responsibility
    * to defer changing the value of TASK_SIZE until the
    * switch really is going to happen - do this in
    * flush_thread(). - akpm
    */
   SET_PERSONALITY(loc->elf_ex, ibcs2_interpreter);

   interpreter = open_exec(elf_interpreter);
   retval = PTR_ERR(interpreter);
   if (IS_ERR(interpreter))
    goto out_free_interp;

   /*
    * If the binary is not readable then enforce
    * mm->dumpable = 0 regardless of the interpreter's
    * permissions.
    */
   if (file_permission(interpreter, MAY_READ) < 0)
    bprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;

   retval = kernel_read(interpreter, 0, bprm->buf,
          BINPRM_BUF_SIZE);
   if (retval != BINPRM_BUF_SIZE) {
    if (retval >= 0)
     retval = -EIO;
    goto out_free_dentry;
   }

   /* Get the exec headers */
   loc->interp_ex = *((struct exec *)bprm->buf);
   loc->interp_elf_ex = *((struct elfhdr *)bprm->buf);
   break;
  }
  elf_ppnt++;
 }

 elf_ppnt = elf_phdata;
 for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)
  if (elf_ppnt->p_type == PT_GNU_STACK) {
   if (elf_ppnt->p_flags & PF_X)
    executable_stack = EXSTACK_ENABLE_X;
   else
    executable_stack = EXSTACK_DISABLE_X;
   break;
  }

 /* Some simple consistency checks for the interpreter */
 if (elf_interpreter) {
  interpreter_type = INTERPRETER_ELF | INTERPRETER_AOUT;

  /* Now figure out which format our binary is */
  if ((N_MAGIC(loc->interp_ex) != OMAGIC) &&
      (N_MAGIC(loc->interp_ex) != ZMAGIC) &&
      (N_MAGIC(loc->interp_ex) != QMAGIC))
   interpreter_type = INTERPRETER_ELF;

  if (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)
   interpreter_type &= ~INTERPRETER_ELF;

  retval = -ELIBBAD;
  if (!interpreter_type)
   goto out_free_dentry;

  /* Make sure only one type was selected */
  if ((interpreter_type & INTERPRETER_ELF) &&
       interpreter_type != INTERPRETER_ELF) {
        // FIXME - ratelimit this before re-enabling
   // printk(KERN_WARNING ""ELF: Ambiguous type, using ELF\n"");
   interpreter_type = INTERPRETER_ELF;
  }
  /* Verify the interpreter has a valid arch */
  if ((interpreter_type == INTERPRETER_ELF) &&
      !elf_check_arch(&loc->interp_elf_ex))
   goto out_free_dentry;
 } else {
  /* Executables without an interpreter also need a personality  */
  SET_PERSONALITY(loc->elf_ex, ibcs2_interpreter);
 }

 /* OK, we are done with that, now set up the arg stuff,
    and then start this sucker up */
 if ((!bprm->sh_bang) && (interpreter_type == INTERPRETER_AOUT)) {
  char *passed_p = passed_fileno;
  sprintf(passed_fileno, ""%d"", elf_exec_fileno);

  if (elf_interpreter) {
   retval = copy_strings_kernel(1, &passed_p, bprm);
   if (retval)
    goto out_free_dentry; 
   bprm->argc++;
  }
 }

 /* Flush all traces of the currently running executable */
 retval = flush_old_exec(bprm);
 if (retval)
  goto out_free_dentry;

 /* Discard our unneeded old files struct */
 if (files) {
  put_files_struct(files);
  files = NULL;
 }

 /* OK, This is the point of no return */
 current->mm->start_data = 0;
 current->mm->end_data = 0;
 current->mm->end_code = 0;
 current->mm->mmap = NULL;
 current->flags &= ~PF_FORKNOEXEC;
 current->mm->def_flags = def_flags;

 /* Do this immediately, since STACK_TOP as used in setup_arg_pages
    may depend on the personality.  */
 SET_PERSONALITY(loc->elf_ex, ibcs2_interpreter);
 if (elf_read_implies_exec(loc->elf_ex, executable_stack))
  current->personality |= READ_IMPLIES_EXEC;

 if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
  current->flags |= PF_RANDOMIZE;
 arch_pick_mmap_layout(current->mm);

 /* Do this so that we can load the interpreter, if need be.  We will
    change some of these later */
 current->mm->free_area_cache = current->mm->mmap_base;
 current->mm->cached_hole_size = 0;
 retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),
     executable_stack);
 if (retval < 0) {
  send_sig(SIGKILL, current, 0);
  goto out_free_dentry;
 }
 
 current->mm->start_stack = bprm->p;

 /* Now we do a little grungy work by mmaping the ELF image into
    the correct location in memory.  At this point, we assume that
    the image should be loaded at fixed address, not at a variable
    address. */
 for(i = 0, elf_ppnt = elf_phdata;
     i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {
  int elf_prot = 0, elf_flags;
  unsigned long k, vaddr;

  if (elf_ppnt->p_type != PT_LOAD)
   continue;

  if (unlikely (elf_brk > elf_bss)) {
   unsigned long nbyte;
             
   /* There was a PT_LOAD segment with p_memsz > p_filesz
      before this one. Map anonymous pages, if needed,
      and clear the area.  */
   retval = set_brk (elf_bss + load_bias,
       elf_brk + load_bias);
   if (retval) {
    send_sig(SIGKILL, current, 0);
    goto out_free_dentry;
   }
   nbyte = ELF_PAGEOFFSET(elf_bss);
   if (nbyte) {
    nbyte = ELF_MIN_ALIGN - nbyte;
    if (nbyte > elf_brk - elf_bss)
     nbyte = elf_brk - elf_bss;
    if (clear_user((void __user *)elf_bss +
       load_bias, nbyte)) {
     /*
      * This bss-zeroing can fail if the ELF
      * file specifies odd protections. So
      * we don't check the return value
      */
    }
   }
  }

  if (elf_ppnt->p_flags & PF_R)
   elf_prot |= PROT_READ;
  if (elf_ppnt->p_flags & PF_W)
   elf_prot |= PROT_WRITE;
  if (elf_ppnt->p_flags & PF_X)
   elf_prot |= PROT_EXEC;

  elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;

  vaddr = elf_ppnt->p_vaddr;
  if (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {
   elf_flags |= MAP_FIXED;
  } else if (loc->elf_ex.e_type == ET_DYN) {
   /* Try and get dynamic programs out of the way of the
    * default mmap base, as well as whatever program they
    * might try to exec.  This is because the brk will
    * follow the loader, and is not movable.  */
   load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
  }

  error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,
    elf_prot, elf_flags);
  if (BAD_ADDR(error)) {
   send_sig(SIGKILL, current, 0);
   goto out_free_dentry;
  }

  if (!load_addr_set) {
   load_addr_set = 1;
   load_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);
   if (loc->elf_ex.e_type == ET_DYN) {
    load_bias += error -
                 ELF_PAGESTART(load_bias + vaddr);
    load_addr += load_bias;
    reloc_func_desc = load_bias;
   }
  }
  k = elf_ppnt->p_vaddr;
  if (k < start_code)
   start_code = k;
  if (start_data < k)
   start_data = k;

  /*
   * Check to see if the section's size will overflow the
   * allowed task size. Note that p_filesz must always be
   * <= p_memsz so it is only necessary to check p_memsz.
   */
  if (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||
      elf_ppnt->p_memsz > TASK_SIZE ||
      TASK_SIZE - elf_ppnt->p_memsz < k) {
   /* set_brk can never work. Avoid overflows. */
   send_sig(SIGKILL, current, 0);
   goto out_free_dentry;
  }

  k = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;

  if (k > elf_bss)
   elf_bss = k;
  if ((elf_ppnt->p_flags & PF_X) && end_code < k)
   end_code = k;
  if (end_data < k)
   end_data = k;
  k = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;
  if (k > elf_brk)
   elf_brk = k;
 }

 loc->elf_ex.e_entry += load_bias;
 elf_bss += load_bias;
 elf_brk += load_bias;
 start_code += load_bias;
 end_code += load_bias;
 start_data += load_bias;
 end_data += load_bias;

 /* Calling set_brk effectively mmaps the pages that we need
  * for the bss and break sections.  We must do this before
  * mapping in the interpreter, to make sure it doesn't wind
  * up getting placed where the bss needs to go.
  */
 retval = set_brk(elf_bss, elf_brk);
 if (retval) {
  send_sig(SIGKILL, current, 0);
  goto out_free_dentry;
 }
 if (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {
  send_sig(SIGSEGV, current, 0);
  retval = -EFAULT; /* Nobody gets to see this, but.. */
  goto out_free_dentry;
 }

 if (elf_interpreter) {
  if (interpreter_type == INTERPRETER_AOUT)
   elf_entry = load_aout_interp(&loc->interp_ex,
           interpreter);
  else
   elf_entry = load_elf_interp(&loc->interp_elf_ex,
          interpreter,
          &interp_load_addr);
  if (BAD_ADDR(elf_entry)) {
   force_sig(SIGSEGV, current);
   retval = IS_ERR((void *)elf_entry) ?
     (int)elf_entry : -EINVAL;
   goto out_free_dentry;
  }
  reloc_func_desc = interp_load_addr;

  allow_write_access(interpreter);
  fput(interpreter);
  kfree(elf_interpreter);
 } else {
  elf_entry = loc->elf_ex.e_entry;
  if (BAD_ADDR(elf_entry)) {
   force_sig(SIGSEGV, current);
   retval = -EINVAL;
   goto out_free_dentry;
  }
 }

 kfree(elf_phdata);

 if (interpreter_type != INTERPRETER_AOUT)
  sys_close(elf_exec_fileno);

 set_binfmt(&elf_format);

#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES
 retval = arch_setup_additional_pages(bprm, executable_stack);
 if (retval < 0) {
  send_sig(SIGKILL, current, 0);
  goto out;
 }
#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */

 compute_creds(bprm);
 current->flags &= ~PF_FORKNOEXEC;
 create_elf_tables(bprm, &loc->elf_ex,
     (interpreter_type == INTERPRETER_AOUT),
     load_addr, interp_load_addr);
 /* N.B. passed_fileno might not be initialized? */
 if (interpreter_type == INTERPRETER_AOUT)
  current->mm->arg_start += strlen(passed_fileno) + 1;
 current->mm->end_code = end_code;
 current->mm->start_code = start_code;
 current->mm->start_data = start_data;
 current->mm->end_data = end_data;
 current->mm->start_stack = bprm->p;

 if (current->personality & MMAP_PAGE_ZERO) {
  /* Why this, you ask???  Well SVr4 maps page 0 as read-only,
     and some applications ""depend"" upon this behavior.
     Since we do not have the power to recompile these, we
     emulate the SVr4 behavior. Sigh. */
  down_write(&current->mm->mmap_sem);
  error = do_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,
    MAP_FIXED | MAP_PRIVATE, 0);
  up_write(&current->mm->mmap_sem);
 }

#ifdef ELF_PLAT_INIT
 /*
  * The ABI may specify that certain registers be set up in special
  * ways (on i386 %edx is the address of a DT_FINI function, for
  * example.  In addition, it may also specify (eg, PowerPC64 ELF)
  * that the e_entry field is the address of the function descriptor
  * for the startup routine, rather than the address of the startup
  * routine itself.  This macro performs whatever initialization to
  * the regs structure is required as well as any relocations to the
  * function descriptor entries when executing dynamically links apps.
  */
 ELF_PLAT_INIT(regs, reloc_func_desc);
#endif

 start_thread(regs, elf_entry, bprm->p);
 if (unlikely(current->ptrace & PT_PTRACED)) {
  if (current->ptrace & PT_TRACE_EXEC)
   ptrace_notify ((PTRACE_EVENT_EXEC << 8) | SIGTRAP);
  else
   send_sig(SIGTRAP, current, 0);
 }
 retval = 0;
out:
 kfree(loc);
out_ret:
 return retval;

 /* error cleanup */
out_free_dentry:
 allow_write_access(interpreter);
 if (interpreter)
  fput(interpreter);
out_free_interp:
 kfree(elf_interpreter);
out_free_file:
 sys_close(elf_exec_fileno);
out_free_fh:
 if (files)
  reset_files_struct(current, files);
out_free_ph:
 kfree(elf_phdata);
 goto out;
}
"
tpm_kdfa.c,"TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,
        TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits,
        TPM2B_MAX_BUFFER  *resultKey )
{
    TPM2B_DIGEST tmpResult;
    TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2;
    UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0];
    UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0];
    TPM2B_DIGEST *bufferList[8];
    UINT32 bitsSwizzled, i_Swizzled;
    TPM_RC rval;
    int i, j;
    UINT16 bytes = bits / 8;

    resultKey->t .size = 0;

    tpm2b_i_2.t.size = 4;

    tpm2bBits.t.size = 4;
    bitsSwizzled = string_bytes_endian_convert_32( bits );
    *(UINT32 *)tpm2bBitsPtr = bitsSwizzled;

    for(i = 0; label[i] != 0 ;i++ );

    tpm2bLabel.t.size = i+1;
    for( i = 0; i < tpm2bLabel.t.size; i++ )
    {
        tpm2bLabel.t.buffer[i] = label[i];
    }

    resultKey->t.size = 0;

    i = 1;

    while( resultKey->t.size < bytes )
    {
        // Inner loop

        i_Swizzled = string_bytes_endian_convert_32( i );
        *(UINT32 *)tpm2b_i_2Ptr = i_Swizzled;

        j = 0;
        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2b_i_2.b);
        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bLabel.b);
        bufferList[j++] = (TPM2B_DIGEST *)contextU;
        bufferList[j++] = (TPM2B_DIGEST *)contextV;
        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b);
        bufferList[j++] = (TPM2B_DIGEST *)0;
        rval = tpm_hmac(sapi_context, hashAlg, key, (TPM2B **)&( bufferList[0] ), &tmpResult );
        if( rval != TPM_RC_SUCCESS )
        {
            return( rval );
        }

        bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b));
        if (!res) {
            return TSS2_SYS_RC_BAD_VALUE;
        }
    }

    // Truncate the result to the desired size.
    resultKey->t.size = bytes;

    return TPM_RC_SUCCESS;
}
","TPM_RC tpm_kdfa(TPMI_ALG_HASH hashAlg,
        TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits,
        TPM2B_MAX_BUFFER  *resultKey )
{
    TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2;
    UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0];
    UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0];
    TPM2B_DIGEST *bufferList[8];
    UINT32 bitsSwizzled, i_Swizzled;
    TPM_RC rval = TPM_RC_SUCCESS;
    int i, j;
    UINT16 bytes = bits / 8;

    resultKey->t .size = 0;

    tpm2b_i_2.t.size = 4;

    tpm2bBits.t.size = 4;
    bitsSwizzled = string_bytes_endian_convert_32( bits );
    *(UINT32 *)tpm2bBitsPtr = bitsSwizzled;

    for(i = 0; label[i] != 0 ;i++ );

    tpm2bLabel.t.size = i+1;
    for( i = 0; i < tpm2bLabel.t.size; i++ )
    {
        tpm2bLabel.t.buffer[i] = label[i];
    }

    resultKey->t.size = 0;

    i = 1;

    const EVP_MD *md = tpm_algorithm_to_openssl_digest(hashAlg);
    if (!md) {
        LOG_ERR(""Algorithm not supported for hmac: %x"", hashAlg);
        return TPM_RC_HASH;
    }

    HMAC_CTX ctx;
    HMAC_CTX_init(&ctx);
    int rc = HMAC_Init_ex(&ctx, key->buffer, key->size, md, NULL);
    if (!rc) {
        LOG_ERR(""HMAC Init failed: %s"", ERR_error_string(rc, NULL));
        return TPM_RC_MEMORY;
    }

    // TODO Why is this a loop? It appears to only execute once.
    while( resultKey->t.size < bytes )
    {
        TPM2B_DIGEST tmpResult;
        // Inner loop

        i_Swizzled = string_bytes_endian_convert_32( i );
        *(UINT32 *)tpm2b_i_2Ptr = i_Swizzled;

        j = 0;
        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2b_i_2.b);
        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bLabel.b);
        bufferList[j++] = (TPM2B_DIGEST *)contextU;
        bufferList[j++] = (TPM2B_DIGEST *)contextV;
        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b);
        bufferList[j] = (TPM2B_DIGEST *)0;

        int c;
        for(c=0; c < j; c++) {
            TPM2B_DIGEST *digest = bufferList[c];
            int rc =  HMAC_Update(&ctx, digest->b.buffer, digest->b.size);
            if (!rc) {
                LOG_ERR(""HMAC Update failed: %s"", ERR_error_string(rc, NULL));
                rval = TPM_RC_MEMORY;
                goto err;
            }
        }

        unsigned size = sizeof(tmpResult.t.buffer);
        int rc = HMAC_Final(&ctx, tmpResult.t.buffer, &size);
        if (!rc) {
            LOG_ERR(""HMAC Final failed: %s"", ERR_error_string(rc, NULL));
            rval = TPM_RC_MEMORY;
            goto err;
        }

        tmpResult.t.size = size;

        bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b));
        if (!res) {
            rval = TSS2_SYS_RC_BAD_VALUE;
            goto err;
        }
    }

    // Truncate the result to the desired size.
    resultKey->t.size = bytes;

err:
    HMAC_CTX_cleanup(&ctx);

    return rval;
}
"
tiffvisitor.cpp,"    void TiffReader::readTiffEntry(TiffEntryBase* object)
    {
        assert(object != 0);

        byte* p = object->start();
        assert(p >= pData_);

        if (p + 12 > pLast_) {
#ifndef SUPPRESS_WARNINGS
            EXV_ERROR << ""Entry in directory "" << groupName(object->group())
                      << ""requests access to memory beyond the data buffer. ""
                      << ""Skipping entry.\n"";
#endif
            return;
        }
        // Component already has tag
        p += 2;
        TiffType tiffType = getUShort(p, byteOrder());
        TypeId typeId = toTypeId(tiffType, object->tag(), object->group());
        long typeSize = TypeInfo::typeSize(typeId);
        if (0 == typeSize) {
#ifndef SUPPRESS_WARNINGS
            EXV_WARNING << ""Directory "" << groupName(object->group())
                        << "", entry 0x"" << std::setw(4)
                        << std::setfill('0') << std::hex << object->tag()
                        << "" has unknown Exif (TIFF) type "" << std::dec << tiffType
                        << ""; setting type size 1.\n"";
#endif
            typeSize = 1;
        }
        p += 2;
        uint32_t count = getULong(p, byteOrder());
        if (count >= 0x10000000) {
#ifndef SUPPRESS_WARNINGS
            EXV_ERROR << ""Directory "" << groupName(object->group())
                      << "", entry 0x"" << std::setw(4)
                      << std::setfill('0') << std::hex << object->tag()
                      << "" has invalid size ""
                      << std::dec << count << ""*"" << typeSize
                      << ""; skipping entry.\n"";
#endif
            return;
        }
        p += 4;
        uint32_t isize= 0; // size of Exif.Sony1.PreviewImage
        uint32_t size = typeSize * count;
        uint32_t offset = getLong(p, byteOrder());
        byte* pData = p;
        if (   size > 4
            && (   baseOffset() + offset >= size_
                || static_cast<int32_t>(baseOffset()) + offset <= 0)) {
                // #1143
                if ( object->tag() == 0x2001 && std::string(groupName(object->group())) == ""Sony1"" ) {
                 isize=size;
                } else {
#ifndef SUPPRESS_WARNINGS
            EXV_ERROR << ""Offset of directory "" << groupName(object->group())
                      << "", entry 0x"" << std::setw(4)
                      << std::setfill('0') << std::hex << object->tag()
                      << "" is out of bounds: ""
                      << ""Offset = 0x"" << std::setw(8)
                      << std::setfill('0') << std::hex << offset
                      << ""; truncating the entry\n"";
#endif
    }
                size = 0;
        }
        if (size > 4) {
            pData = const_cast<byte*>(pData_) + baseOffset() + offset;
            if (size > static_cast<uint32_t>(pLast_ - pData)) {
#ifndef SUPPRESS_WARNINGS
                EXV_ERROR << ""Upper boundary of data for ""
                          << ""directory "" << groupName(object->group())
                          << "", entry 0x"" << std::setw(4)
                          << std::setfill('0') << std::hex << object->tag()
                          << "" is out of bounds: ""
                          << ""Offset = 0x"" << std::setw(8)
                          << std::setfill('0') << std::hex << offset
                          << "", size = "" << std::dec << size
                          << "", exceeds buffer size by ""
                          // cast to make MSVC happy
                          << static_cast<uint32_t>(pData + size - pLast_)
                          << "" Bytes; truncating the entry\n"";
#endif
                size = 0;
            }
        }
        Value::AutoPtr v = Value::create(typeId);
        assert(v.get());
        if ( !isize ) {
         v->read(pData, size, byteOrder());
        } else {
         // #1143 Write a ""hollow"" buffer for the preview image
         //       Sadly: we don't know the exact location of the image in the source (it's near offset)
         //       And neither TiffReader nor TiffEntryBase have access to the BasicIo object being processed
         byte* buffer = (byte*) ::malloc(isize);
         ::memset(buffer,0,isize);
         v->read(buffer,isize, byteOrder());
         ::free(buffer);
        }

        object->setValue(v);
        object->setData(pData, size);
        object->setOffset(offset);
        object->setIdx(nextIdx(object->group()));

    } // TiffReader::readTiffEntry
","    void TiffReader::readTiffEntry(TiffEntryBase* object)
    {
        assert(object != 0);

        byte* p = object->start();
        assert(p >= pData_);

        if (p + 12 > pLast_) {
#ifndef SUPPRESS_WARNINGS
            EXV_ERROR << ""Entry in directory "" << groupName(object->group())
                      << ""requests access to memory beyond the data buffer. ""
                      << ""Skipping entry.\n"";
#endif
            return;
        }
        // Component already has tag
        p += 2;
        TiffType tiffType = getUShort(p, byteOrder());
        TypeId typeId = toTypeId(tiffType, object->tag(), object->group());
        long typeSize = TypeInfo::typeSize(typeId);
        if (0 == typeSize) {
#ifndef SUPPRESS_WARNINGS
            EXV_WARNING << ""Directory "" << groupName(object->group())
                        << "", entry 0x"" << std::setw(4)
                        << std::setfill('0') << std::hex << object->tag()
                        << "" has unknown Exif (TIFF) type "" << std::dec << tiffType
                        << ""; setting type size 1.\n"";
#endif
            typeSize = 1;
        }
        p += 2;
        uint32_t count = getULong(p, byteOrder());
        if (count >= 0x10000000) {
#ifndef SUPPRESS_WARNINGS
            EXV_ERROR << ""Directory "" << groupName(object->group())
                      << "", entry 0x"" << std::setw(4)
                      << std::setfill('0') << std::hex << object->tag()
                      << "" has invalid size ""
                      << std::dec << count << ""*"" << typeSize
                      << ""; skipping entry.\n"";
#endif
            return;
        }
        p += 4;
        uint32_t isize= 0; // size of Exif.Sony1.PreviewImage
        uint32_t size = typeSize * count;
        uint32_t offset = getLong(p, byteOrder());
        byte* pData = p;
        if (   size > 4
            && (   baseOffset() + offset >= size_
                || static_cast<int32_t>(baseOffset()) + offset <= 0)) {
                // #1143
                if ( object->tag() == 0x2001 && std::string(groupName(object->group())) == ""Sony1"" ) {
                 isize=size;
                } else {
#ifndef SUPPRESS_WARNINGS
            EXV_ERROR << ""Offset of directory "" << groupName(object->group())
                      << "", entry 0x"" << std::setw(4)
                      << std::setfill('0') << std::hex << object->tag()
                      << "" is out of bounds: ""
                      << ""Offset = 0x"" << std::setw(8)
                      << std::setfill('0') << std::hex << offset
                      << ""; truncating the entry\n"";
#endif
    }
                size = 0;
        }
        if (size > 4) {
            // setting pData to pData_ + baseOffset() + offset can result in pData pointing to invalid memory,
            // as offset can be arbitrarily large
            if ((static_cast<uintptr_t>(baseOffset()) > std::numeric_limits<uintptr_t>::max() - static_cast<uintptr_t>(offset))
             || (static_cast<uintptr_t>(baseOffset() + offset) > std::numeric_limits<uintptr_t>::max() - reinterpret_cast<uintptr_t>(pData_)))
            {
                throw Error(59);
            }
            if (pData_ + static_cast<uintptr_t>(baseOffset()) + static_cast<uintptr_t>(offset) > pLast_) {
                throw Error(58);
            }
            pData = const_cast<byte*>(pData_) + baseOffset() + offset;

     // check for size being invalid
            if (size > static_cast<uint32_t>(pLast_ - pData)) {
#ifndef SUPPRESS_WARNINGS
                EXV_ERROR << ""Upper boundary of data for ""
                          << ""directory "" << groupName(object->group())
                          << "", entry 0x"" << std::setw(4)
                          << std::setfill('0') << std::hex << object->tag()
                          << "" is out of bounds: ""
                          << ""Offset = 0x"" << std::setw(8)
                          << std::setfill('0') << std::hex << offset
                          << "", size = "" << std::dec << size
                          << "", exceeds buffer size by ""
                          // cast to make MSVC happy
                          << static_cast<uint32_t>(pData + size - pLast_)
                          << "" Bytes; truncating the entry\n"";
#endif
                size = 0;
            }
        }
        Value::AutoPtr v = Value::create(typeId);
        assert(v.get());
        if ( !isize ) {
         v->read(pData, size, byteOrder());
        } else {
         // #1143 Write a ""hollow"" buffer for the preview image
         //       Sadly: we don't know the exact location of the image in the source (it's near offset)
         //       And neither TiffReader nor TiffEntryBase have access to the BasicIo object being processed
         byte* buffer = (byte*) ::malloc(isize);
         ::memset(buffer,0,isize);
         v->read(buffer,isize, byteOrder());
         ::free(buffer);
        }

        object->setValue(v);
        object->setData(pData, size);
        object->setOffset(offset);
        object->setIdx(nextIdx(object->group()));

    } // TiffReader::readTiffEntry
"
LookupConfigForm.java,"    public LookupConfigForm() {

        initLang();

        configTextArea.setText(MainForm.configStr);
        configTextArea.setCaretPosition(0);

        refreshConfigButton.addActionListener(e -> {
            if (!StringUtil.notEmpty(MainForm.configPath)) {
                JOptionPane.showMessageDialog(null, ""无法刷新"");
                return;
            }
            try {
                byte[] data = Files.readAllBytes(Paths.get(MainForm.configPath));
                configTextArea.setText(null);
                configTextArea.setText(new String(data));
            } catch (Exception ex) {
                ex.printStackTrace();
            }
            JOptionPane.showMessageDialog(null, ""已刷新配置"");
        });

        saveConfigButton.addActionListener(e -> {
            if (!StringUtil.notEmpty(MainForm.configPath)) {
                JOptionPane.showMessageDialog(null, ""无法保存"");
                return;
            }
            try {
                Yaml yaml = new Yaml();
                String newConfig = configTextArea.getText();
                MainForm.configObj = yaml.load(newConfig);

                MainForm.configStr = newConfig;

                MainForm.instance.reloadConfig(false, false);

                Files.write(Paths.get(MainForm.configPath),
                        newConfig.getBytes(StandardCharsets.UTF_8));
                JOptionPane.showMessageDialog(null, ""已保存配置"");
            } catch (Exception ex) {
                JOptionPane.showMessageDialog(null, ""您的配置有误"");
                ex.printStackTrace();
            }
        });
    }
","    public LookupConfigForm() {

        initLang();

        configTextArea.setText(MainForm.configStr);
        configTextArea.setCaretPosition(0);

        refreshConfigButton.addActionListener(e -> {
            if (!StringUtil.notEmpty(MainForm.configPath)) {
                JOptionPane.showMessageDialog(null, ""无法刷新"");
                return;
            }
            try {
                byte[] data = Files.readAllBytes(Paths.get(MainForm.configPath));
                configTextArea.setText(null);
                configTextArea.setText(new String(data));
            } catch (Exception ex) {
                ex.printStackTrace();
            }
            JOptionPane.showMessageDialog(null, ""已刷新配置"");
        });

        saveConfigButton.addActionListener(e -> {
            if (!StringUtil.notEmpty(MainForm.configPath)) {
                JOptionPane.showMessageDialog(null, ""无法保存"");
                return;
            }
            try {
                Yaml yaml = new Yaml(new SafeConstructor(new LoaderOptions()));
                String newConfig = configTextArea.getText();
                MainForm.configObj = yaml.load(newConfig);

                MainForm.configStr = newConfig;

                MainForm.instance.reloadConfig(false, false);

                Files.write(Paths.get(MainForm.configPath),
                        newConfig.getBytes(StandardCharsets.UTF_8));
                JOptionPane.showMessageDialog(null, ""已保存配置"");
            } catch (Exception ex) {
                JOptionPane.showMessageDialog(null, ""您的配置有误"");
                ex.printStackTrace();
            }
        });
    }
"
bcon.c,"static bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state) {
    bcon_error_t ret = BCON_OK;
    bcon_state_t state = start_state;
    char *key = 0;
    char *typespec = 0;
    unsigned char doc_stack[DOC_STACK_SIZE];
    size_t doc_stack_pointer = 0;
    size_t array_index = 0;
    unsigned int array_index_stack[ARRAY_INDEX_STACK_SIZE];
    size_t array_index_stack_pointer = 0;
    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; /* max BSON size */
    int end_of_data;
    const bcon *bcp;
    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {
        bcon bci = *bcp;
        char *s = bci.s;
        switch (state) {
        case State_Element:
            switch (bcon_token(s)) {
            case Token_CloseBrace:
                bson_append_finish_object( b );
                DOC_POP_STATE; /* state = ...; */
                break;
            case Token_End:
                end_of_data = 1;
                break;
            default:
                key = s;
                state = State_DocSpecValue;
                break;
            }
            break;
        case State_DocSpecValue:
            switch (bcon_token(s)) {
            case Token_Typespec:
                typespec = s;
                state = State_DocValue;
                break;
            case Token_OpenBrace:
                bson_append_start_object( b, key );
                DOC_PUSH_STATE(State_Element);
                state = State_Element;
                break;
            case Token_OpenBracket:
                bson_append_start_array( b, key );
                ARRAY_PUSH_RESET_INDEX_STATE(State_Element);
                state = State_ArraySpecValue;
                break;
            case Token_End:
                end_of_data = 1;
                break;
            default:
                ret = bson_bcon_key_value(b, key, typespec, bci);
                state = State_Element;
                break;
            }
            break;
        case State_DocValue:
            ret = bson_bcon_key_value(b, key, typespec, bci);
            state = State_Element;
            typespec = 0;
            break;
        case State_ArraySpecValue:
            switch (bcon_token(s)) {
            case Token_Typespec:
                typespec = s;
                state = State_ArrayValue;
                break;
            case Token_OpenBrace:
                key = ARRAY_KEY_STRING(array_index++);
                bson_append_start_object( b, key );
                DOC_PUSH_STATE(State_ArraySpecValue);
                state = State_Element;
                break;
            case Token_OpenBracket:
                key = ARRAY_KEY_STRING(array_index++);
                bson_append_start_array( b, key );
                ARRAY_PUSH_RESET_INDEX_STATE(State_ArraySpecValue);
                /* state = State_ArraySpecValue; */
                break;
            case Token_CloseBracket:
                bson_append_finish_array( b );
                ARRAY_POP_INDEX_STATE; /* state = ...; */
                break;
            case Token_End:
                end_of_data = 1;
                break;
            default:
                key = ARRAY_KEY_STRING(array_index++);
                ret = bson_bcon_key_value(b, key, typespec, bci);
                /* state = State_ArraySpecValue; */
                break;
            }
            break;
        case State_ArrayValue:
            key = ARRAY_KEY_STRING(array_index++);
            ret = bson_bcon_key_value(b, key, typespec, bci);
            state = State_ArraySpecValue;
            typespec = 0;
            break;
        default: assert(NOT_REACHED); break;
        }
    }
    return state == start_state ? BCON_OK : BCON_DOCUMENT_INCOMPLETE;
}
","static bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state) {
    bcon_error_t ret = BCON_OK;
    bcon_state_t state = start_state;
    char *key = 0;
    char *typespec = 0;
    unsigned char doc_stack[DOC_STACK_SIZE];
    size_t doc_stack_pointer = 0;
    size_t array_index = 0;
    size_t array_index_stack[ARRAY_INDEX_STACK_SIZE];
    size_t array_index_stack_pointer = 0;
    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; /* max BSON size */
    int end_of_data;
    const bcon *bcp;
    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {
        bcon bci = *bcp;
        char *s = bci.s;
        switch (state) {
        case State_Element:
            switch (bcon_token(s)) {
            case Token_CloseBrace:
                bson_append_finish_object( b );
                DOC_POP_STATE; /* state = ...; */
                break;
            case Token_End:
                end_of_data = 1;
                break;
            default:
                key = s;
                state = State_DocSpecValue;
                break;
            }
            break;
        case State_DocSpecValue:
            switch (bcon_token(s)) {
            case Token_Typespec:
                typespec = s;
                state = State_DocValue;
                break;
            case Token_OpenBrace:
                bson_append_start_object( b, key );
                DOC_PUSH_STATE(State_Element);
                state = State_Element;
                break;
            case Token_OpenBracket:
                bson_append_start_array( b, key );
                ARRAY_PUSH_RESET_INDEX_STATE(State_Element);
                state = State_ArraySpecValue;
                break;
            case Token_End:
                end_of_data = 1;
                break;
            default:
                ret = bson_bcon_key_value(b, key, typespec, bci);
                state = State_Element;
                break;
            }
            break;
        case State_DocValue:
            ret = bson_bcon_key_value(b, key, typespec, bci);
            state = State_Element;
            typespec = 0;
            break;
        case State_ArraySpecValue:
            switch (bcon_token(s)) {
            case Token_Typespec:
                typespec = s;
                state = State_ArrayValue;
                break;
            case Token_OpenBrace:
                key = ARRAY_KEY_STRING(array_index++);
                bson_append_start_object( b, key );
                DOC_PUSH_STATE(State_ArraySpecValue);
                state = State_Element;
                break;
            case Token_OpenBracket:
                key = ARRAY_KEY_STRING(array_index++);
                bson_append_start_array( b, key );
                ARRAY_PUSH_RESET_INDEX_STATE(State_ArraySpecValue);
                /* state = State_ArraySpecValue; */
                break;
            case Token_CloseBracket:
                bson_append_finish_array( b );
                ARRAY_POP_INDEX_STATE; /* state = ...; */
                break;
            case Token_End:
                end_of_data = 1;
                break;
            default:
                key = ARRAY_KEY_STRING(array_index++);
                ret = bson_bcon_key_value(b, key, typespec, bci);
                /* state = State_ArraySpecValue; */
                break;
            }
            break;
        case State_ArrayValue:
            key = ARRAY_KEY_STRING(array_index++);
            ret = bson_bcon_key_value(b, key, typespec, bci);
            state = State_ArraySpecValue;
            typespec = 0;
            break;
        default: assert(NOT_REACHED); break;
        }
    }
    return state == start_state ? BCON_OK : BCON_DOCUMENT_INCOMPLETE;
}
"
AdminInterceptor.java,"    private void adminPermission(Invocation ai) {
        Controller controller = ai.getController();
        AdminTokenVO adminTokenVO = adminTokenService.getAdminTokenVO(controller.getRequest());
        if (adminTokenVO != null) {
            try {
                User user = new User().findById(adminTokenVO.getUserId());
                if (StringUtils.isEmpty(user.getStr(""header""))) {
                    user.set(""header"", Constants.DEFAULT_HEADER);
                }
                controller.setAttr(""user"", user);
                controller.setAttr(""protocol"", adminTokenVO.getProtocol());
                TemplateHelper.fullTemplateInfo(controller, false);
                if (!""/admin/logout"".equals(ai.getActionKey())) {
                    adminTokenService.setAdminToken(user, adminTokenVO.getSessionId(), adminTokenVO.getProtocol(), controller.getRequest(), controller.getResponse());
                }
                ai.invoke();
                // 存在消息提示
                if (controller.getAttr(""message"") != null) {
                    AdminPageController.initIndex(controller.getRequest());
                    controller.render(new FreeMarkerRender(""/admin/index.ftl""));
                } else {
                    if (!tryDoRender(ai, controller)) {
                        controller.renderHtml(IOUtil.getStringInputStream(new FileInputStream(PathKit.getWebRootPath() + Constants.NOT_FOUND_PAGE)));
                    }
                }
            } catch (Exception e) {
                LOGGER.error("""", e);
                exceptionHandler(ai, e);
            } finally {
                AdminTokenThreadLocal.remove();
            }
        } else if (""/admin/login"".equals(ai.getActionKey()) || ""/api/admin/login"".equals(ai.getActionKey())) {
            ai.invoke();
            tryDoRender(ai, controller);
        } else {
            blockUnLoginRequestHandler(ai);
        }
    }
","    private void adminPermission(Invocation ai) {
        Controller controller = ai.getController();
        AdminTokenVO adminTokenVO = adminTokenService.getAdminTokenVO(controller.getRequest());
        if (adminTokenVO != null) {
            try {
                User user = new User().findById(adminTokenVO.getUserId());
                if (StringUtils.isEmpty(user.getStr(""header""))) {
                    user.set(""header"", Constants.DEFAULT_HEADER);
                }
                controller.setAttr(""user"", user);
                controller.setAttr(""protocol"", adminTokenVO.getProtocol());
                TemplateHelper.fullTemplateInfo(controller, false);
                if (!""/admin/logout"".equals(ai.getActionKey())) {
                    adminTokenService.setAdminToken(user, adminTokenVO.getSessionId(), adminTokenVO.getProtocol(), controller.getRequest(), controller.getResponse());
                }
                ai.invoke();
                // 存在消息提示
                if (controller.getAttr(""message"") != null) {
                    initIndex(controller.getRequest());
                    controller.render(new FreeMarkerRender(""/admin/index.ftl""));
                } else {
                    if (!tryDoRender(ai, controller)) {
                        controller.renderHtml(IOUtil.getStringInputStream(new FileInputStream(PathKit.getWebRootPath() + Constants.NOT_FOUND_PAGE)));
                    }
                }
            } catch (Exception e) {
                LOGGER.error("""", e);
                exceptionHandler(ai, e);
            } finally {
                AdminTokenThreadLocal.remove();
            }
        } else if (""/admin/login"".equals(ai.getActionKey()) || ""/api/admin/login"".equals(ai.getActionKey())) {
            ai.invoke();
            tryDoRender(ai, controller);
        } else {
            blockUnLoginRequestHandler(ai);
        }
    }
"
acl.c,"acl__resource_match_aci( Acl_PBlock *aclpb, aci_t *aci, int skip_attrEval, int *a_matched)
{

 struct slapi_filter  *f;   /* filter */
 int      rv;   /* return value */
 /* Assume that resource matches */
 int      matches = ACL_TRUE;
 int      attr_matched = ACL_TRUE;
 int      attr_matched_in_targetattrfilters = 0;
 int      dn_matched;
 char     *res_attr;
 int      aci_right = 0;
 int      res_right = 0;
 int      star_matched = ACL_FALSE;
 int      num_attrs = 0;
 AclAttrEval    *c_attrEval = NULL;
 const char   *res_ndn = NULL;
 const char   *aci_ndn = NULL;
 char     *matched_val = NULL; 
 int      add_matched_val_to_ht = 0;
 char      res_right_str[128];

 TNF_PROBE_0_DEBUG(acl__resource_match_aci_start,""ACL"","""");

 if (NULL == aclpb) {
  matches = ACL_FALSE;
  goto acl__resource_match_aci_EXIT;   
 }

 /* Figure out if the acl has the correct rights or not */
 aci_right = aci->aci_access;
 res_right = aclpb->aclpb_access;
 if (!(aci_right & res_right)) {
  /* If we are looking for read/search and the acl has read/search
  ** then go further because if targets match we may keep that
  ** acl in  the entry cache list.
  */
  if (!((res_right & (SLAPI_ACL_SEARCH | SLAPI_ACL_READ)) &&
   (aci_right & (SLAPI_ACL_SEARCH | SLAPI_ACL_READ))))
   matches = ACL_FALSE;
   goto acl__resource_match_aci_EXIT;   
 }

 
 /* first Let's see if the entry is under the subtree where the
 ** ACL resides. We can't let somebody affect a target beyond the 
 ** scope of where the ACL resides
 ** Example: ACL is located in ""ou=engineering, o=ace industry, c=us
 ** but if the target is ""o=ace industry, c=us"", then we are in trouble.
 **
 ** If the aci is in the rootdse and the entry is not, then we do not
 ** match--ie. acis in the rootdse do NOT apply below...for the moment.
 ** 
 */
 res_ndn = slapi_sdn_get_ndn ( aclpb->aclpb_curr_entry_sdn );
 aci_ndn = slapi_sdn_get_ndn ( aci->aci_sdn );
 if (!slapi_sdn_issuffix(aclpb->aclpb_curr_entry_sdn, aci->aci_sdn)
  || (!slapi_is_rootdse(res_ndn) && slapi_is_rootdse(aci_ndn)) ) {

  /* cant' poke around */
  matches = ACL_FALSE;
  goto acl__resource_match_aci_EXIT;   
 }
 
 /*
 ** We have a single ACI which we need to find if it applies to
 ** the resource or not.
 */
 if ((aci->aci_type & ACI_TARGET_DN) && (aclpb->aclpb_curr_entry_sdn)) {
  char  *avaType;
  struct berval *avaValue;  

  f = aci->target; 
  dn_matched = ACL_TRUE;
  slapi_filter_get_ava ( f, &avaType, &avaValue );
  
  if (!slapi_dn_issuffix( res_ndn, avaValue->bv_val)) {
   dn_matched = ACL_FALSE;
  }
  if (aci->aci_type & ACI_TARGET_NOT) {
   matches = (dn_matched ? ACL_FALSE : ACL_TRUE);
  } else {
   matches = (dn_matched ? ACL_TRUE: ACL_FALSE);
  }
 }
 
 /* No need to look further */
 if (matches == ACL_FALSE) {
  goto acl__resource_match_aci_EXIT; 
 }

 if (aci->aci_type & ACI_TARGET_PATTERN) {
  
  f = aci->target; 
  dn_matched = ACL_TRUE;
 
  if ((rv = acl_match_substring(f, (char *)res_ndn, 0 /* match suffux */)) != ACL_TRUE) {
   dn_matched = ACL_FALSE;
   if(rv == ACL_ERR) {
    slapi_log_error(SLAPI_LOG_ACL, plugin_name, 
     ""acl__resource_match_aci:pattern err\n"");
    matches = ACL_FALSE;
    goto acl__resource_match_aci_EXIT; 
   }
  }
  if (aci->aci_type & ACI_TARGET_NOT) {
   matches = (dn_matched ? ACL_FALSE : ACL_TRUE);
  } else {
   matches = (dn_matched ? ACL_TRUE: ACL_FALSE);
  }
 }

 /* No need to look further */
 if (matches == ACL_FALSE) {
  goto acl__resource_match_aci_EXIT; 
 }

 /*
  * Is it a (target=""ldap://cn=*,($dn),o=sun.com"") kind of thing.
 */
 if (aci->aci_type & ACI_TARGET_MACRO_DN) {
  /*
   * See if the ($dn) component matches the string and
   * retrieve the matched substring for later use
   * in the userdn.
   * The macro string is a function of the dn only, so if the
   * entry is the same one don't recalculate it--
   * this flag only works for search right now, could
   * also optimise for mods by making it work for mods.
  */
   
  if ( (aclpb->aclpb_res_type & ACLPB_NEW_ENTRY) == 0 ) {
   /*
    * Here same entry so just look up the matched value,
    * calculated from the targetdn and stored judiciously there
    */
   matched_val = (char *)acl_ht_lookup( aclpb->aclpb_macro_ht,
          (PLHashNumber)aci->aci_index);
  }
  if ( matched_val == NULL &&
   (aclpb->aclpb_res_type & (ACLPB_NEW_ENTRY | ACLPB_EFFECTIVE_RIGHTS))) {

   slapi_log_error (SLAPI_LOG_ACL, plugin_name,
    ""Evaluating macro aci(%d)%s for resource %s\n"",
    aci->aci_index, aci->aclName,
    aclutil__access_str(res_right, res_right_str));
   matched_val = acl_match_macro_in_target( res_ndn,
            aci->aci_macro->match_this,
            aci->aci_macro->macro_ptr);
   add_matched_val_to_ht = 1; /* may need to add matched value to ht */
  }
  if (matched_val == NULL) {
   dn_matched = ACL_FALSE;
  } else {
   dn_matched = ACL_TRUE;
  }
              
  if (aci->aci_type & ACI_TARGET_NOT) {
   matches = (dn_matched ? ACL_FALSE : ACL_TRUE);
  } else {
   matches = (dn_matched ? ACL_TRUE: ACL_FALSE);
  }
  
  if ( add_matched_val_to_ht ) {
   if ( matches == ACL_TRUE && matched_val ) {
    /*
     * matched_val may be needed later for matching on
     * other targets or on the subject--so optimistically
     * put it in the hash table.
     * If, at the end of this routine, we
     * find that after all the resource did not match then
     * that's ok--the value is freed at aclpb cleanup time.
     * If there is already an entry for this aci in this
     * aclpb then remove it--it's an old value for a
     * different entry.
    */

    acl_ht_add_and_freeOld(aclpb->aclpb_macro_ht,
         (PLHashNumber)aci->aci_index,
         matched_val);
    slapi_log_error (SLAPI_LOG_ACL, plugin_name,
     ""-- Added aci(%d) and matched value (%s) to macro ht\n"",
     aci->aci_index, matched_val);
    acl_ht_display_ht(aclpb->aclpb_macro_ht);
   } else {
    slapi_ch_free((void **)&matched_val);
    if (matches == ACL_FALSE) {
     slapi_log_error (SLAPI_LOG_ACL, plugin_name,
      ""Evaluated ACL_FALSE\n"");
    }
   }
  }
 } /* MACRO_DN */

 /* No need to look further */
 if (matches == ACL_FALSE) {
  goto acl__resource_match_aci_EXIT; 
 }

 /* 
 ** Here, if there's a targetfilter field, see if it matches.
 **
 ** The commented out code below was an erroneous attempt to skip
 ** this test.  It is wrong because: 1. you need to store
 ** whether the last test matched or not (you cannot just assume it did)
 ** and 2. It may not be the same aci, so the previous matched
 ** value is a function of the aci.
 ** May be interesting to build such a cache...but no evidence for
 ** for that right now. See Bug 383424.
 **
 ** 
 **   && ((aclpb->aclpb_state & ACLPB_SEARCH_BASED_ON_LIST) ||
 ** (aclpb->aclpb_res_type & ACLPB_NEW_ENTRY))
 */
 if (aci->aci_type & ACI_TARGET_FILTER ) {
  int  filter_matched = ACL_TRUE;

  /*
   * Check for macros.
   * For targetfilter we need to fake the lasinfo structure--it's
   * created ""naturally"" for subjects but not targets.
  */
  

  if ( aci->aci_type &  ACI_TARGET_FILTER_MACRO_DN) {   
    
   lasInfo *lasinfo = NULL;
   
   lasinfo = (lasInfo*) slapi_ch_malloc( sizeof(lasInfo) );

   lasinfo->aclpb = aclpb;
   lasinfo->resourceEntry = aclpb->aclpb_curr_entry;
   aclpb->aclpb_curr_aci = aci;
   filter_matched = aclutil_evaluate_macro( aci->targetFilterStr,
             lasinfo,
             ACL_EVAL_TARGET_FILTER);
   slapi_ch_free((void**)&lasinfo);
  } else {


   if (slapi_vattr_filter_test(NULL, aclpb->aclpb_curr_entry, 
    aci->targetFilter,
    0 /*don't do acess chk*/)!= 0) {
    filter_matched = ACL_FALSE;
   }

  }

  /* If it's a logical value we can do logic on it...otherwise we do not match */
  if ( filter_matched == ACL_TRUE || filter_matched == ACL_FALSE) {
   if (aci->aci_type & ACI_TARGET_FILTER_NOT) {
    matches = (filter_matched == ACL_TRUE ? ACL_FALSE : ACL_TRUE);
   } else {
    matches = (filter_matched == ACL_TRUE ? ACL_TRUE: ACL_FALSE);
   }
  } else {
   matches = ACL_FALSE;
   slapi_log_error( SLAPI_LOG_ACL, plugin_name,
    ""Returning UNDEFINED for targetfilter evaluation.\n"");
  }

  if (matches == ACL_FALSE) {
   goto acl__resource_match_aci_EXIT; 
  }
 }

 /*
  * Check to see if we need to evaluate any targetattrfilters.
  * They look as follows:
  * (targetattrfilters=""add=sn:(sn=rob) && gn:(gn!=byrne),
  *        del=sn:(sn=rob) && gn:(gn=byrne)"")
  *
  * For ADD/DELETE:
  * If theres's a targetattrfilter then each add/del filter
  * that applies to an attribute in the entry, must be satisfied
  * by each value of the attribute in the entry.
  *
  * For MODIFY:
  * If there's a targetattrfilter then the add/del filter
  * must be satisfied by the attribute to be added/deleted.
  * (MODIFY acl is evaluated one value at a time).
  * 
  *
 */

 if (((aclpb->aclpb_access & SLAPI_ACL_ADD) &&
   (aci->aci_type & ACI_TARGET_ATTR_ADD_FILTERS) )||
  ((aclpb->aclpb_access & SLAPI_ACL_DELETE) && 
   (aci->aci_type & ACI_TARGET_ATTR_DEL_FILTERS) ) ) {
  
   Targetattrfilter **attrFilterArray;

   Targetattrfilter *attrFilter = NULL;

   Slapi_Attr *attr_ptr = NULL;
   Slapi_Value *sval;
   const struct berval *attrVal;
   int k;
   int done;


   if (aclpb->aclpb_access & SLAPI_ACL_ADD &&
    aci->aci_type & ACI_TARGET_ATTR_ADD_FILTERS) {

    attrFilterArray = aci->targetAttrAddFilters;

   } else if (aclpb->aclpb_access & SLAPI_ACL_DELETE && 
      aci->aci_type & ACI_TARGET_ATTR_DEL_FILTERS) {
    
    attrFilterArray = aci->targetAttrDelFilters;

   }

   attr_matched = ACL_TRUE;
   num_attrs = 0;

   while (attrFilterArray[num_attrs] && attr_matched) {
    attrFilter = attrFilterArray[num_attrs];

    /* 
     * If this filter applies to an attribute in the entry,
     * apply it to the entry.
     * Otherwise just ignore it.
     * 
    */

    if (slapi_entry_attr_find ( aclpb->aclpb_curr_entry,
             attrFilter->attr_str,
             &attr_ptr) == 0)  {

     /*
      * This is an applicable filter.
      *  The filter is to be appplied to the entry being added
      * or deleted.
      * The filter needs to be satisfied by _each_ occurence
      * of the attribute in the entry--otherwise you
      * could satisfy the filter and then put loads of other
      * values in on the back of it.
      */

     sval=NULL;
     attrVal=NULL;
     k= slapi_attr_first_value(attr_ptr,&sval);
     done = 0;
     while(k != -1 && !done) {
      attrVal = slapi_value_get_berval(sval);

      if ( acl__make_filter_test_entry(
                             &aclpb->aclpb_filter_test_entry,
        attrFilter->attr_str,
        (struct berval *)attrVal) == LDAP_SUCCESS ) {                      
    
       attr_matched= acl__test_filter( 
                                  aclpb->aclpb_filter_test_entry,
                attrFilter->filter,
                1 /* Do filter sense evaluation below */
           );
       done = !attr_matched;
       slapi_entry_free( aclpb->aclpb_filter_test_entry );   
      }                                           
      
      k= slapi_attr_next_value(attr_ptr, k, &sval);
     }/* while */

     /*
      * Here, we applied an applicable filter to the entry.
      * So if attr_matched is ACL_TRUE then every value
      * of the attribute in the entry satisfied the filter.
      * Otherwise, attr_matched is ACL_FALSE and not every 
      * value satisfied the filter, so we will teminate the
      * scan of the filter list.     
     */

    }

    num_attrs++;
   } /* while */

  /*
   * Here, we've applied all the applicable filters to the entry.
   * Each one must have been satisfied by all the values of the attribute.
   * The result of this is stored in attr_matched.
  */  

#if 0  
  /*
   * Don't support a notion of ""add != "" or ""del != ""
   * at the moment.
   * To do this, need to test whether it's an add test or del test
   * then if it's add and ACI_TARGET_ATTR_ADD_FILTERS_NOT then
   * flip the bit.  Same for del.
  */

  if (aci->aci_type & ACI_TARGET_ATTR_DEL_FILTERS_NOT) {
   matches = (matches ? ACL_FALSE : ACL_TRUE);
  } else {
   matches = (matches ? ACL_TRUE: ACL_FALSE);
  }
#endif

  /* No need to look further */
  if (attr_matched == ACL_FALSE) {
   matches = ACL_FALSE;
   goto acl__resource_match_aci_EXIT; 
  }

 } else  if ( ((aclpb->aclpb_access & ACLPB_SLAPI_ACL_WRITE_ADD) &&
                  (aci->aci_type & ACI_TARGET_ATTR_ADD_FILTERS)) ||
                 ((aclpb->aclpb_access & ACLPB_SLAPI_ACL_WRITE_DEL) &&
                  (aci->aci_type & ACI_TARGET_ATTR_DEL_FILTERS)) ) {

            
  /*     
   * Here, it's a modify add/del and we have attr filters.  
   * So, we need to scan the add/del filter list to find the filter
   * that applies to the current attribute.
   * Then the (attribute,value) pair being added/deleted better
   * match that filter.
   *
   *
   */

  Targetattrfilter **attrFilterArray = NULL;
  Targetattrfilter *attrFilter;
  int found = 0;

  if ((aclpb->aclpb_access & ACLPB_SLAPI_ACL_WRITE_ADD) &&
   (aci->aci_type & ACI_TARGET_ATTR_ADD_FILTERS)) {

   attrFilterArray = aci->targetAttrAddFilters;

  } else if ((aclpb->aclpb_access & ACLPB_SLAPI_ACL_WRITE_DEL) && 
       (aci->aci_type & ACI_TARGET_ATTR_DEL_FILTERS)) {
    
   attrFilterArray = aci->targetAttrDelFilters;

  }
  

  /*
   * Scan this filter list for an applicable filter.
   */

  found = 0;
  num_attrs = 0;

  while (attrFilterArray[num_attrs] && !found) {
    attrFilter = attrFilterArray[num_attrs];

   /* If this filter applies to the attribute, stop. */
   if ((aclpb->aclpb_curr_attrEval) &&
    slapi_attr_type_cmp ( aclpb->aclpb_curr_attrEval->attrEval_name,
           attrFilter->attr_str, 1) == 0) {
    found = 1;
   }
   num_attrs++;
  }

  /*
   * Here, if found an applicable filter, then apply the filter to the 
   * (attr,val) pair.
   * Otherwise, ignore the targetattrfilters.
  */

  if (found) {

   if ( acl__make_filter_test_entry(
                             &aclpb->aclpb_filter_test_entry,
        aclpb->aclpb_curr_attrEval->attrEval_name,
        aclpb->aclpb_curr_attrVal) == LDAP_SUCCESS ) {                      
    
    attr_matched= acl__test_filter(aclpb->aclpb_filter_test_entry,
          attrFilter->filter,
          1 /* Do filter sense evaluation below */
          );                            
    slapi_entry_free( aclpb->aclpb_filter_test_entry );   
   }           

   /* No need to look further */
   if (attr_matched == ACL_FALSE) {
    matches = attr_matched;
    goto acl__resource_match_aci_EXIT;
   }

   /*
    * Here this attribute appeared and was matched in a
    * targetattrfilters list, so record this fact so we do
    * not have to scan the targetattr list for the attribute.
   */
  
   attr_matched_in_targetattrfilters = 1;
  }                                
 } /* targetvaluefilters */ 
 

 /* There are 3 cases  by which acis are selected.
 ** 1) By scanning the whole list and picking based on the resource.
 ** 2) By picking a subset of the list which will be used for the whole
 **    acl evaluation. 
 ** 3) A finer granularity, i.e, a selected list of acls which will be
 ** used for only that entry's evaluation.
 */
 if ( !(skip_attrEval) && (aclpb->aclpb_state & ACLPB_SEARCH_BASED_ON_ENTRY_LIST) &&
  (res_right & SLAPI_ACL_SEARCH) && 
  ((aci->aci_access & SLAPI_ACL_READ) || (aci->aci_access & SLAPI_ACL_SEARCH))) {
  int kk=0;

  while ( kk < aclpb_max_selected_acls && aclpb->aclpb_handles_index[kk] >=0 ) kk++;
  if (kk >= aclpb_max_selected_acls)  {
   aclpb->aclpb_state &= ~ACLPB_SEARCH_BASED_ON_ENTRY_LIST;
  } else {
   aclpb->aclpb_handles_index[kk++] = aci->aci_index;
   aclpb->aclpb_handles_index[kk] = -1;
  }
 }


 /* If we are suppose to skip attr eval, then let's skip it */
 if ( (aclpb->aclpb_access & SLAPI_ACL_SEARCH ) && ( ! skip_attrEval ) &&
  ( aclpb->aclpb_res_type &  ACLPB_NEW_ENTRY )) {
  aclEvalContext  *c_evalContext = &aclpb->aclpb_curr_entryEval_context;
  int   nhandle = c_evalContext->acle_numof_tmatched_handles;

  if ( nhandle < aclpb_max_selected_acls) {
     c_evalContext->acle_handles_matched_target[nhandle] = aci->aci_index;
     c_evalContext->acle_numof_tmatched_handles++;
  }
 }

 if ( skip_attrEval ) {
  goto acl__resource_match_aci_EXIT;
 }

 /* We need to check again because we don't want to select this handle 
 ** if the right doesn't match for now.
 */
 if (!(aci_right & res_right)) {
  matches = ACL_FALSE;
  goto acl__resource_match_aci_EXIT;
 }

    /*
     * Here if the request is one that requires matching 
     * on a targetattr then do it here.
     * If we have already matched an attribute in the targetattrfitlers list
     * then we do not require a match in the targetattr so we can skip it.
     * The operations that require targetattr are SLAPI_ACL_COMPARE,
     * SLAPI_ACL_SEARCH, SLAPI_ACL_READ and SLAPI_ACL_WRITE, as long as
     * c_attrEval is non-null (otherwise it's a modrdn op which
     * does not require the targetattr list).   
     *
  * rbyrneXXX if we had a proper permission for modrdn eg SLAPI_ACL_MODRDN
  * then we would not need this crappy way of telling it was a MODRDN
  * request ie. SLAPI_ACL_WRITE && !(c_attrEval).
    */
    
 c_attrEval = aclpb->aclpb_curr_attrEval;
    
    /*
     * If we've already matched on targattrfilter then do not
     * bother to look at the attrlist.
    */
    
    if (!attr_matched_in_targetattrfilters) {                
            
 /* match target attr */
 if ((c_attrEval) && 
  (aci->aci_type & ACI_TARGET_ATTR)) {
   /* there is a target ATTR */
   Targetattr **attrArray = aci->targetAttr;
   Targetattr *attr = NULL;

   res_attr = c_attrEval->attrEval_name;
   attr_matched = ACL_FALSE;
   star_matched = ACL_FALSE;
   num_attrs = 0;

   while (attrArray[num_attrs] && !attr_matched) {
    attr = attrArray[num_attrs];           
             if (attr->attr_type & ACL_ATTR_STRING) { 
     if (slapi_attr_type_cmp ( res_attr, 
             attr->u.attr_str, 1) == 0) {
      attr_matched = ACL_TRUE;
      *a_matched = ACL_TRUE;
     } 
    } else if (attr->attr_type & ACL_ATTR_FILTER) {
     if (ACL_TRUE == acl_match_substring (
        attr->u.attr_filter, 
        res_attr, 1)) {
      attr_matched = ACL_TRUE;
      *a_matched = ACL_TRUE;
     }
    } else if (attr->attr_type & ACL_ATTR_STAR) {
     attr_matched = ACL_TRUE;
     *a_matched = ACL_TRUE;
     star_matched = ACL_TRUE;
    } 
    num_attrs++;
   }

   if (aci->aci_type & ACI_TARGET_ATTR_NOT) {
    matches = (attr_matched ? ACL_FALSE : ACL_TRUE);
   } else {
    matches = (attr_matched ? ACL_TRUE: ACL_FALSE);
   }


   aclpb->aclpb_state &= ~ACLPB_ATTR_STAR_MATCHED;
   /* figure out how it matched, i.e star matched */
   if (matches && star_matched && num_attrs == 1 &&
    !(aclpb->aclpb_state & ACLPB_FOUND_ATTR_RULE))
    aclpb->aclpb_state |= ACLPB_ATTR_STAR_MATCHED;
   else {
    /* we are here means that there is a specific 
    ** attr in the rule for this resource.
    ** We need to avoid this case
    ** Rule 1: (targetattr = ""uid"")
    ** Rule 2: (targetattr = ""*"")
    ** we cannot use STAR optimization
    */
    aclpb->aclpb_state |=  ACLPB_FOUND_ATTR_RULE;
    aclpb->aclpb_state &=  ~ACLPB_ATTR_STAR_MATCHED;
   }
 } else if ( (c_attrEval) ||
      (aci->aci_type & ACI_TARGET_ATTR)) {
  if ((aci_right & ACL_RIGHTS_TARGETATTR_NOT_NEEDED) &&
      (aclpb->aclpb_access & ACL_RIGHTS_TARGETATTR_NOT_NEEDED)) {
   /* 
   ** Targetattr rule doesn't  make any sense
   ** in this case. So select this rule
   ** default: matches = ACL_TRUE;
   */
   ;
  } else if (aci_right & SLAPI_ACL_WRITE && 
     (aci->aci_type & ACI_TARGET_ATTR) &&
     !(c_attrEval) &&
     (aci->aci_type & ACI_HAS_ALLOW_RULE)) {
   /* We need to handle modrdn operation.  Modrdn doesn't 
   ** change any attrs but changes the RDN and so (attr=NULL).
   ** Here we found an acl which has a targetattr but
   ** the resource doesn't need one. In that case, we should
   ** consider this acl.
   ** the opposite is true if it is a deny rule, only a deny without 
   ** any targetattr should deny modrdn
   ** default: matches = ACL_TRUE;
   */
   ;
  } else {
   matches = ACL_FALSE;
  }
 }
 }/* !attr_matched_in_targetattrfilters */
   
 /* 
 ** Here we are testing if we find a entry test rule (which should
 ** be rare). In that case, just remember it. An entry test rule
 ** doesn't have ""(targetattr)"".
 */
 if ((aclpb->aclpb_state & ACLPB_EVALUATING_FIRST_ATTR) &&
  (!(aci->aci_type & ACI_TARGET_ATTR))) {
  aclpb->aclpb_state |= ACLPB_FOUND_A_ENTRY_TEST_RULE;
 }

 /*
  * Generic exit point for this routine:
  * matches is ACL_TRUE if the aci matches the target of the resource,
  * ACL_FALSE othrewise.
  * Apologies for the goto--this is a retro-fitted exit point.
 */
acl__resource_match_aci_EXIT:

 /*
  * For macro acis, there may be a partial macro string
  * placed in the aclpb_macro_ht
  * even if the aci did not finally match.
  * All the partial strings will be freed at aclpb
  * cleanup time.
  */
 if (ACL_TRUE == matches) {
  aclpb->aclpb_stat_aclres_matched++;
 }

 TNF_PROBE_0_DEBUG(acl__resource_match_aci_end,""ACL"","""");

 return (matches);
}
","acl__resource_match_aci( Acl_PBlock *aclpb, aci_t *aci, int skip_attrEval, int *a_matched)
{

 struct slapi_filter  *f;   /* filter */
 int      rv;   /* return value */
 /* Assume that resource matches */
 int      matches = ACL_TRUE;
 int      attr_matched = ACL_TRUE;
 int      attr_matched_in_targetattrfilters = 0;
 int      dn_matched;
 char     *res_attr;
 int      aci_right = 0;
 int      res_right = 0;
 int      star_matched = ACL_FALSE;
 int      num_attrs = 0;
 AclAttrEval    *c_attrEval = NULL;
 const char   *res_ndn = NULL;
 const char   *aci_ndn = NULL;
 char     *matched_val = NULL; 
 int      add_matched_val_to_ht = 0;
 char      res_right_str[128];

 TNF_PROBE_0_DEBUG(acl__resource_match_aci_start,""ACL"","""");

 if (NULL == aclpb) {
  matches = ACL_FALSE;
  goto acl__resource_match_aci_EXIT;   
 }

 /* Figure out if the acl has the correct rights or not */
 aci_right = aci->aci_access;
 res_right = aclpb->aclpb_access;
 if (!(aci_right & res_right)) {
  /* If we are looking for read/search and the acl has read/search
  ** then go further because if targets match we may keep that
  ** acl in  the entry cache list.
  */
  if (!((res_right & (SLAPI_ACL_SEARCH | SLAPI_ACL_READ)) &&
   (aci_right & (SLAPI_ACL_SEARCH | SLAPI_ACL_READ))))
   matches = ACL_FALSE;
   goto acl__resource_match_aci_EXIT;   
 }

 
 /* first Let's see if the entry is under the subtree where the
 ** ACL resides. We can't let somebody affect a target beyond the 
 ** scope of where the ACL resides
 ** Example: ACL is located in ""ou=engineering, o=ace industry, c=us
 ** but if the target is ""o=ace industry, c=us"", then we are in trouble.
 **
 ** If the aci is in the rootdse and the entry is not, then we do not
 ** match--ie. acis in the rootdse do NOT apply below...for the moment.
 ** 
 */
 res_ndn = slapi_sdn_get_ndn ( aclpb->aclpb_curr_entry_sdn );
 aci_ndn = slapi_sdn_get_ndn ( aci->aci_sdn );
 if (!slapi_sdn_issuffix(aclpb->aclpb_curr_entry_sdn, aci->aci_sdn)
  || (!slapi_is_rootdse(res_ndn) && slapi_is_rootdse(aci_ndn)) ) {

  /* cant' poke around */
  matches = ACL_FALSE;
  goto acl__resource_match_aci_EXIT;   
 }
 
 /*
 ** We have a single ACI which we need to find if it applies to
 ** the resource or not.
 */
 if ((aci->aci_type & ACI_TARGET_DN) && (aclpb->aclpb_curr_entry_sdn)) {
  char  *avaType;
  struct berval *avaValue;  

  f = aci->target; 
  dn_matched = ACL_TRUE;
  slapi_filter_get_ava ( f, &avaType, &avaValue );
  
  if (!slapi_dn_issuffix( res_ndn, avaValue->bv_val)) {
   dn_matched = ACL_FALSE;
  }
  if (aci->aci_type & ACI_TARGET_NOT) {
   matches = (dn_matched ? ACL_FALSE : ACL_TRUE);
  } else {
   matches = (dn_matched ? ACL_TRUE: ACL_FALSE);
  }
 }
 
 /* No need to look further */
 if (matches == ACL_FALSE) {
  goto acl__resource_match_aci_EXIT; 
 }

 if (aci->aci_type & ACI_TARGET_PATTERN) {
  
  f = aci->target; 
  dn_matched = ACL_TRUE;
 
  if ((rv = acl_match_substring(f, (char *)res_ndn, 0 /* match suffux */)) != ACL_TRUE) {
   dn_matched = ACL_FALSE;
   if(rv == ACL_ERR) {
    slapi_log_error(SLAPI_LOG_ACL, plugin_name, 
     ""acl__resource_match_aci:pattern err\n"");
    matches = ACL_FALSE;
    goto acl__resource_match_aci_EXIT; 
   }
  }
  if (aci->aci_type & ACI_TARGET_NOT) {
   matches = (dn_matched ? ACL_FALSE : ACL_TRUE);
  } else {
   matches = (dn_matched ? ACL_TRUE: ACL_FALSE);
  }
 }

 /* No need to look further */
 if (matches == ACL_FALSE) {
  goto acl__resource_match_aci_EXIT; 
 }

 /*
  * Is it a (target=""ldap://cn=*,($dn),o=sun.com"") kind of thing.
 */
 if (aci->aci_type & ACI_TARGET_MACRO_DN) {
  /*
   * See if the ($dn) component matches the string and
   * retrieve the matched substring for later use
   * in the userdn.
   * The macro string is a function of the dn only, so if the
   * entry is the same one don't recalculate it--
   * this flag only works for search right now, could
   * also optimise for mods by making it work for mods.
  */
   
  if ( (aclpb->aclpb_res_type & ACLPB_NEW_ENTRY) == 0 ) {
   /*
    * Here same entry so just look up the matched value,
    * calculated from the targetdn and stored judiciously there
    */
   matched_val = (char *)acl_ht_lookup( aclpb->aclpb_macro_ht,
        (PLHashNumber)aci->aci_index);
  } else {
   /* new entry, remove macro evaluation from hash table */
   acl_ht_remove_and_free( aclpb->aclpb_macro_ht,
       (PLHashNumber)aci->aci_index);
  }
  if ( matched_val == NULL &&
   (aclpb->aclpb_res_type & (ACLPB_NEW_ENTRY | ACLPB_EFFECTIVE_RIGHTS))) {

   slapi_log_error (SLAPI_LOG_ACL, plugin_name,
    ""Evaluating macro aci(%d)%s for resource %s\n"",
    aci->aci_index, aci->aclName,
    aclutil__access_str(res_right, res_right_str));
   matched_val = acl_match_macro_in_target( res_ndn,
            aci->aci_macro->match_this,
            aci->aci_macro->macro_ptr);
   add_matched_val_to_ht = 1; /* may need to add matched value to ht */
  }
  if (matched_val == NULL) {
   dn_matched = ACL_FALSE;
  } else {
   dn_matched = ACL_TRUE;
  }
              
  if (aci->aci_type & ACI_TARGET_NOT) {
   matches = (dn_matched ? ACL_FALSE : ACL_TRUE);
  } else {
   matches = (dn_matched ? ACL_TRUE: ACL_FALSE);
  }
  
  if ( add_matched_val_to_ht ) {
   if ( matches == ACL_TRUE && matched_val ) {
    /*
     * matched_val may be needed later for matching on
     * other targets or on the subject--so optimistically
     * put it in the hash table.
     * If, at the end of this routine, we
     * find that after all the resource did not match then
     * that's ok--the value is freed at aclpb cleanup time.
     * If there is already an entry for this aci in this
     * aclpb then remove it--it's an old value for a
     * different entry.
    */

    acl_ht_add_and_freeOld(aclpb->aclpb_macro_ht,
         (PLHashNumber)aci->aci_index,
         matched_val);
    slapi_log_error (SLAPI_LOG_ACL, plugin_name,
     ""-- Added aci(%d) and matched value (%s) to macro ht\n"",
     aci->aci_index, matched_val);
    acl_ht_display_ht(aclpb->aclpb_macro_ht);
   } else {
    slapi_ch_free((void **)&matched_val);
    if (matches == ACL_FALSE) {
     slapi_log_error (SLAPI_LOG_ACL, plugin_name,
      ""Evaluated ACL_FALSE\n"");
    }
   }
  }
 } /* MACRO_DN */

 /* No need to look further */
 if (matches == ACL_FALSE) {
  goto acl__resource_match_aci_EXIT; 
 }

 /* 
 ** Here, if there's a targetfilter field, see if it matches.
 **
 ** The commented out code below was an erroneous attempt to skip
 ** this test.  It is wrong because: 1. you need to store
 ** whether the last test matched or not (you cannot just assume it did)
 ** and 2. It may not be the same aci, so the previous matched
 ** value is a function of the aci.
 ** May be interesting to build such a cache...but no evidence for
 ** for that right now. See Bug 383424.
 **
 ** 
 **   && ((aclpb->aclpb_state & ACLPB_SEARCH_BASED_ON_LIST) ||
 ** (aclpb->aclpb_res_type & ACLPB_NEW_ENTRY))
 */
 if (aci->aci_type & ACI_TARGET_FILTER ) {
  int  filter_matched = ACL_TRUE;

  /*
   * Check for macros.
   * For targetfilter we need to fake the lasinfo structure--it's
   * created ""naturally"" for subjects but not targets.
  */
  

  if ( aci->aci_type &  ACI_TARGET_FILTER_MACRO_DN) {   
    
   lasInfo *lasinfo = NULL;
   
   lasinfo = (lasInfo*) slapi_ch_malloc( sizeof(lasInfo) );

   lasinfo->aclpb = aclpb;
   lasinfo->resourceEntry = aclpb->aclpb_curr_entry;
   aclpb->aclpb_curr_aci = aci;
   filter_matched = aclutil_evaluate_macro( aci->targetFilterStr,
             lasinfo,
             ACL_EVAL_TARGET_FILTER);
   slapi_ch_free((void**)&lasinfo);
  } else {


   if (slapi_vattr_filter_test(NULL, aclpb->aclpb_curr_entry, 
    aci->targetFilter,
    0 /*don't do acess chk*/)!= 0) {
    filter_matched = ACL_FALSE;
   }

  }

  /* If it's a logical value we can do logic on it...otherwise we do not match */
  if ( filter_matched == ACL_TRUE || filter_matched == ACL_FALSE) {
   if (aci->aci_type & ACI_TARGET_FILTER_NOT) {
    matches = (filter_matched == ACL_TRUE ? ACL_FALSE : ACL_TRUE);
   } else {
    matches = (filter_matched == ACL_TRUE ? ACL_TRUE: ACL_FALSE);
   }
  } else {
   matches = ACL_FALSE;
   slapi_log_error( SLAPI_LOG_ACL, plugin_name,
    ""Returning UNDEFINED for targetfilter evaluation.\n"");
  }

  if (matches == ACL_FALSE) {
   goto acl__resource_match_aci_EXIT; 
  }
 }

 /*
  * Check to see if we need to evaluate any targetattrfilters.
  * They look as follows:
  * (targetattrfilters=""add=sn:(sn=rob) && gn:(gn!=byrne),
  *        del=sn:(sn=rob) && gn:(gn=byrne)"")
  *
  * For ADD/DELETE:
  * If theres's a targetattrfilter then each add/del filter
  * that applies to an attribute in the entry, must be satisfied
  * by each value of the attribute in the entry.
  *
  * For MODIFY:
  * If there's a targetattrfilter then the add/del filter
  * must be satisfied by the attribute to be added/deleted.
  * (MODIFY acl is evaluated one value at a time).
  * 
  *
 */

 if (((aclpb->aclpb_access & SLAPI_ACL_ADD) &&
   (aci->aci_type & ACI_TARGET_ATTR_ADD_FILTERS) )||
  ((aclpb->aclpb_access & SLAPI_ACL_DELETE) && 
   (aci->aci_type & ACI_TARGET_ATTR_DEL_FILTERS) ) ) {
  
   Targetattrfilter **attrFilterArray;

   Targetattrfilter *attrFilter = NULL;

   Slapi_Attr *attr_ptr = NULL;
   Slapi_Value *sval;
   const struct berval *attrVal;
   int k;
   int done;


   if (aclpb->aclpb_access & SLAPI_ACL_ADD &&
    aci->aci_type & ACI_TARGET_ATTR_ADD_FILTERS) {

    attrFilterArray = aci->targetAttrAddFilters;

   } else if (aclpb->aclpb_access & SLAPI_ACL_DELETE && 
      aci->aci_type & ACI_TARGET_ATTR_DEL_FILTERS) {
    
    attrFilterArray = aci->targetAttrDelFilters;

   }

   attr_matched = ACL_TRUE;
   num_attrs = 0;

   while (attrFilterArray[num_attrs] && attr_matched) {
    attrFilter = attrFilterArray[num_attrs];

    /* 
     * If this filter applies to an attribute in the entry,
     * apply it to the entry.
     * Otherwise just ignore it.
     * 
    */

    if (slapi_entry_attr_find ( aclpb->aclpb_curr_entry,
             attrFilter->attr_str,
             &attr_ptr) == 0)  {

     /*
      * This is an applicable filter.
      *  The filter is to be appplied to the entry being added
      * or deleted.
      * The filter needs to be satisfied by _each_ occurence
      * of the attribute in the entry--otherwise you
      * could satisfy the filter and then put loads of other
      * values in on the back of it.
      */

     sval=NULL;
     attrVal=NULL;
     k= slapi_attr_first_value(attr_ptr,&sval);
     done = 0;
     while(k != -1 && !done) {
      attrVal = slapi_value_get_berval(sval);

      if ( acl__make_filter_test_entry(
                             &aclpb->aclpb_filter_test_entry,
        attrFilter->attr_str,
        (struct berval *)attrVal) == LDAP_SUCCESS ) {                      
    
       attr_matched= acl__test_filter( 
                                  aclpb->aclpb_filter_test_entry,
                attrFilter->filter,
                1 /* Do filter sense evaluation below */
           );
       done = !attr_matched;
       slapi_entry_free( aclpb->aclpb_filter_test_entry );   
      }                                           
      
      k= slapi_attr_next_value(attr_ptr, k, &sval);
     }/* while */

     /*
      * Here, we applied an applicable filter to the entry.
      * So if attr_matched is ACL_TRUE then every value
      * of the attribute in the entry satisfied the filter.
      * Otherwise, attr_matched is ACL_FALSE and not every 
      * value satisfied the filter, so we will teminate the
      * scan of the filter list.     
     */

    }

    num_attrs++;
   } /* while */

  /*
   * Here, we've applied all the applicable filters to the entry.
   * Each one must have been satisfied by all the values of the attribute.
   * The result of this is stored in attr_matched.
  */  

#if 0  
  /*
   * Don't support a notion of ""add != "" or ""del != ""
   * at the moment.
   * To do this, need to test whether it's an add test or del test
   * then if it's add and ACI_TARGET_ATTR_ADD_FILTERS_NOT then
   * flip the bit.  Same for del.
  */

  if (aci->aci_type & ACI_TARGET_ATTR_DEL_FILTERS_NOT) {
   matches = (matches ? ACL_FALSE : ACL_TRUE);
  } else {
   matches = (matches ? ACL_TRUE: ACL_FALSE);
  }
#endif

  /* No need to look further */
  if (attr_matched == ACL_FALSE) {
   matches = ACL_FALSE;
   goto acl__resource_match_aci_EXIT; 
  }

 } else  if ( ((aclpb->aclpb_access & ACLPB_SLAPI_ACL_WRITE_ADD) &&
                  (aci->aci_type & ACI_TARGET_ATTR_ADD_FILTERS)) ||
                 ((aclpb->aclpb_access & ACLPB_SLAPI_ACL_WRITE_DEL) &&
                  (aci->aci_type & ACI_TARGET_ATTR_DEL_FILTERS)) ) {

            
  /*     
   * Here, it's a modify add/del and we have attr filters.  
   * So, we need to scan the add/del filter list to find the filter
   * that applies to the current attribute.
   * Then the (attribute,value) pair being added/deleted better
   * match that filter.
   *
   *
   */

  Targetattrfilter **attrFilterArray = NULL;
  Targetattrfilter *attrFilter;
  int found = 0;

  if ((aclpb->aclpb_access & ACLPB_SLAPI_ACL_WRITE_ADD) &&
   (aci->aci_type & ACI_TARGET_ATTR_ADD_FILTERS)) {

   attrFilterArray = aci->targetAttrAddFilters;

  } else if ((aclpb->aclpb_access & ACLPB_SLAPI_ACL_WRITE_DEL) && 
       (aci->aci_type & ACI_TARGET_ATTR_DEL_FILTERS)) {
    
   attrFilterArray = aci->targetAttrDelFilters;

  }
  

  /*
   * Scan this filter list for an applicable filter.
   */

  found = 0;
  num_attrs = 0;

  while (attrFilterArray[num_attrs] && !found) {
    attrFilter = attrFilterArray[num_attrs];

   /* If this filter applies to the attribute, stop. */
   if ((aclpb->aclpb_curr_attrEval) &&
    slapi_attr_type_cmp ( aclpb->aclpb_curr_attrEval->attrEval_name,
           attrFilter->attr_str, 1) == 0) {
    found = 1;
   }
   num_attrs++;
  }

  /*
   * Here, if found an applicable filter, then apply the filter to the 
   * (attr,val) pair.
   * Otherwise, ignore the targetattrfilters.
  */

  if (found) {

   if ( acl__make_filter_test_entry(
                             &aclpb->aclpb_filter_test_entry,
        aclpb->aclpb_curr_attrEval->attrEval_name,
        aclpb->aclpb_curr_attrVal) == LDAP_SUCCESS ) {                      
    
    attr_matched= acl__test_filter(aclpb->aclpb_filter_test_entry,
          attrFilter->filter,
          1 /* Do filter sense evaluation below */
          );                            
    slapi_entry_free( aclpb->aclpb_filter_test_entry );   
   }           

   /* No need to look further */
   if (attr_matched == ACL_FALSE) {
    matches = attr_matched;
    goto acl__resource_match_aci_EXIT;
   }

   /*
    * Here this attribute appeared and was matched in a
    * targetattrfilters list, so record this fact so we do
    * not have to scan the targetattr list for the attribute.
   */
  
   attr_matched_in_targetattrfilters = 1;
  }                                
 } /* targetvaluefilters */ 
 

 /* There are 3 cases  by which acis are selected.
 ** 1) By scanning the whole list and picking based on the resource.
 ** 2) By picking a subset of the list which will be used for the whole
 **    acl evaluation. 
 ** 3) A finer granularity, i.e, a selected list of acls which will be
 ** used for only that entry's evaluation.
 */
 if ( !(skip_attrEval) && (aclpb->aclpb_state & ACLPB_SEARCH_BASED_ON_ENTRY_LIST) &&
  (res_right & SLAPI_ACL_SEARCH) && 
  ((aci->aci_access & SLAPI_ACL_READ) || (aci->aci_access & SLAPI_ACL_SEARCH))) {
  int kk=0;

  while ( kk < aclpb_max_selected_acls && aclpb->aclpb_handles_index[kk] >=0 ) kk++;
  if (kk >= aclpb_max_selected_acls)  {
   aclpb->aclpb_state &= ~ACLPB_SEARCH_BASED_ON_ENTRY_LIST;
  } else {
   aclpb->aclpb_handles_index[kk++] = aci->aci_index;
   aclpb->aclpb_handles_index[kk] = -1;
  }
 }


 /* If we are suppose to skip attr eval, then let's skip it */
 if ( (aclpb->aclpb_access & SLAPI_ACL_SEARCH ) && ( ! skip_attrEval ) &&
  ( aclpb->aclpb_res_type &  ACLPB_NEW_ENTRY )) {
  aclEvalContext  *c_evalContext = &aclpb->aclpb_curr_entryEval_context;
  int   nhandle = c_evalContext->acle_numof_tmatched_handles;

  if ( nhandle < aclpb_max_selected_acls) {
     c_evalContext->acle_handles_matched_target[nhandle] = aci->aci_index;
     c_evalContext->acle_numof_tmatched_handles++;
  }
 }

 if ( skip_attrEval ) {
  goto acl__resource_match_aci_EXIT;
 }

 /* We need to check again because we don't want to select this handle 
 ** if the right doesn't match for now.
 */
 if (!(aci_right & res_right)) {
  matches = ACL_FALSE;
  goto acl__resource_match_aci_EXIT;
 }

    /*
     * Here if the request is one that requires matching 
     * on a targetattr then do it here.
     * If we have already matched an attribute in the targetattrfitlers list
     * then we do not require a match in the targetattr so we can skip it.
     * The operations that require targetattr are SLAPI_ACL_COMPARE,
     * SLAPI_ACL_SEARCH, SLAPI_ACL_READ and SLAPI_ACL_WRITE, as long as
     * c_attrEval is non-null (otherwise it's a modrdn op which
     * does not require the targetattr list).   
     *
  * rbyrneXXX if we had a proper permission for modrdn eg SLAPI_ACL_MODRDN
  * then we would not need this crappy way of telling it was a MODRDN
  * request ie. SLAPI_ACL_WRITE && !(c_attrEval).
    */
    
 c_attrEval = aclpb->aclpb_curr_attrEval;
    
    /*
     * If we've already matched on targattrfilter then do not
     * bother to look at the attrlist.
    */
    
    if (!attr_matched_in_targetattrfilters) {                
            
 /* match target attr */
 if ((c_attrEval) && 
  (aci->aci_type & ACI_TARGET_ATTR)) {
   /* there is a target ATTR */
   Targetattr **attrArray = aci->targetAttr;
   Targetattr *attr = NULL;

   res_attr = c_attrEval->attrEval_name;
   attr_matched = ACL_FALSE;
   star_matched = ACL_FALSE;
   num_attrs = 0;

   while (attrArray[num_attrs] && !attr_matched) {
    attr = attrArray[num_attrs];           
             if (attr->attr_type & ACL_ATTR_STRING) { 
     if (slapi_attr_type_cmp ( res_attr, 
             attr->u.attr_str, 1) == 0) {
      attr_matched = ACL_TRUE;
      *a_matched = ACL_TRUE;
     } 
    } else if (attr->attr_type & ACL_ATTR_FILTER) {
     if (ACL_TRUE == acl_match_substring (
        attr->u.attr_filter, 
        res_attr, 1)) {
      attr_matched = ACL_TRUE;
      *a_matched = ACL_TRUE;
     }
    } else if (attr->attr_type & ACL_ATTR_STAR) {
     attr_matched = ACL_TRUE;
     *a_matched = ACL_TRUE;
     star_matched = ACL_TRUE;
    } 
    num_attrs++;
   }

   if (aci->aci_type & ACI_TARGET_ATTR_NOT) {
    matches = (attr_matched ? ACL_FALSE : ACL_TRUE);
   } else {
    matches = (attr_matched ? ACL_TRUE: ACL_FALSE);
   }


   aclpb->aclpb_state &= ~ACLPB_ATTR_STAR_MATCHED;
   /* figure out how it matched, i.e star matched */
   if (matches && star_matched && num_attrs == 1 &&
    !(aclpb->aclpb_state & ACLPB_FOUND_ATTR_RULE))
    aclpb->aclpb_state |= ACLPB_ATTR_STAR_MATCHED;
   else {
    /* we are here means that there is a specific 
    ** attr in the rule for this resource.
    ** We need to avoid this case
    ** Rule 1: (targetattr = ""uid"")
    ** Rule 2: (targetattr = ""*"")
    ** we cannot use STAR optimization
    */
    aclpb->aclpb_state |=  ACLPB_FOUND_ATTR_RULE;
    aclpb->aclpb_state &=  ~ACLPB_ATTR_STAR_MATCHED;
   }
 } else if ( (c_attrEval) ||
      (aci->aci_type & ACI_TARGET_ATTR)) {
  if ((aci_right & ACL_RIGHTS_TARGETATTR_NOT_NEEDED) &&
      (aclpb->aclpb_access & ACL_RIGHTS_TARGETATTR_NOT_NEEDED)) {
   /* 
   ** Targetattr rule doesn't  make any sense
   ** in this case. So select this rule
   ** default: matches = ACL_TRUE;
   */
   ;
  } else if (aci_right & SLAPI_ACL_WRITE && 
     (aci->aci_type & ACI_TARGET_ATTR) &&
     !(c_attrEval) &&
     (aci->aci_type & ACI_HAS_ALLOW_RULE)) {
   /* We need to handle modrdn operation.  Modrdn doesn't 
   ** change any attrs but changes the RDN and so (attr=NULL).
   ** Here we found an acl which has a targetattr but
   ** the resource doesn't need one. In that case, we should
   ** consider this acl.
   ** the opposite is true if it is a deny rule, only a deny without 
   ** any targetattr should deny modrdn
   ** default: matches = ACL_TRUE;
   */
   ;
  } else {
   matches = ACL_FALSE;
  }
 }
 }/* !attr_matched_in_targetattrfilters */
   
 /* 
 ** Here we are testing if we find a entry test rule (which should
 ** be rare). In that case, just remember it. An entry test rule
 ** doesn't have ""(targetattr)"".
 */
 if ((aclpb->aclpb_state & ACLPB_EVALUATING_FIRST_ATTR) &&
  (!(aci->aci_type & ACI_TARGET_ATTR))) {
  aclpb->aclpb_state |= ACLPB_FOUND_A_ENTRY_TEST_RULE;
 }

 /*
  * Generic exit point for this routine:
  * matches is ACL_TRUE if the aci matches the target of the resource,
  * ACL_FALSE othrewise.
  * Apologies for the goto--this is a retro-fitted exit point.
 */
acl__resource_match_aci_EXIT:

 /*
  * For macro acis, there may be a partial macro string
  * placed in the aclpb_macro_ht
  * even if the aci did not finally match.
  * All the partial strings will be freed at aclpb
  * cleanup time.
  */
 if (ACL_TRUE == matches) {
  aclpb->aclpb_stat_aclres_matched++;
 }

 TNF_PROBE_0_DEBUG(acl__resource_match_aci_end,""ACL"","""");

 return (matches);
}
"
BookServiceImpl.java,"    public void addBookContent(Long bookId, String indexName, String content, Byte isVip, Long authorId) {

        Book book = queryBookDetail(bookId);
        if (!authorId.equals(book.getAuthorId())) {
            //并不是更新自己的小说
            return;
        }
        Long lastIndexId = IdWorker.INSTANCE.nextId();
        Date currentDate = new Date();
        int wordCount = StringUtil.getStrValidWordCount(content);

        //更新小说主表信息
        bookMapper.update(update(BookDynamicSqlSupport.book)
                .set(BookDynamicSqlSupport.lastIndexId)
                .equalTo(lastIndexId)
                .set(BookDynamicSqlSupport.lastIndexName)
                .equalTo(indexName)
                .set(BookDynamicSqlSupport.lastIndexUpdateTime)
                .equalTo(currentDate)
                .set(BookDynamicSqlSupport.wordCount)
                .equalTo(book.getWordCount() + wordCount)
                .where(id, isEqualTo(bookId))
                .and(BookDynamicSqlSupport.authorId, isEqualTo(authorId))
                .build()
                .render(RenderingStrategies.MYBATIS3));

        //计算价格
        int bookPrice = new BigDecimal(wordCount).multiply(bookPriceConfig.getValue()).divide(bookPriceConfig.getWordCount(),0, RoundingMode.DOWN).intValue();

        //更新小说目录表
        int indexNum = 0;
        if (book.getLastIndexId() != null) {
            indexNum = queryBookIndex(book.getLastIndexId()).getIndexNum() + 1;
        }
        BookIndex lastBookIndex = new BookIndex();
        lastBookIndex.setId(lastIndexId);
        lastBookIndex.setWordCount(wordCount);
        lastBookIndex.setIndexName(indexName);
        lastBookIndex.setIndexNum(indexNum);
        lastBookIndex.setBookId(bookId);
        lastBookIndex.setIsVip(isVip);
        lastBookIndex.setBookPrice(bookPrice);
        lastBookIndex.setCreateTime(currentDate);
        lastBookIndex.setUpdateTime(currentDate);
        bookIndexMapper.insertSelective(lastBookIndex);

        //更新小说内容表
        BookContent bookContent = new BookContent();
        bookContent.setIndexId(lastIndexId);
        bookContent.setContent(content);
        bookContentMapper.insertSelective(bookContent);


    }
","    public void addBookContent(Long bookId, String indexName, String content, Byte isVip, Long authorId) {

        Book book = queryBookDetail(bookId);
        if (!authorId.equals(book.getAuthorId())) {
            //并不是更新自己的小说
            return;
        }
        Long lastIndexId = idWorker.nextId();
        Date currentDate = new Date();
        int wordCount = StringUtil.getStrValidWordCount(content);

        //更新小说主表信息
        bookMapper.update(update(BookDynamicSqlSupport.book)
                .set(BookDynamicSqlSupport.lastIndexId)
                .equalTo(lastIndexId)
                .set(BookDynamicSqlSupport.lastIndexName)
                .equalTo(indexName)
                .set(BookDynamicSqlSupport.lastIndexUpdateTime)
                .equalTo(currentDate)
                .set(BookDynamicSqlSupport.wordCount)
                .equalTo(book.getWordCount() + wordCount)
                .where(id, isEqualTo(bookId))
                .and(BookDynamicSqlSupport.authorId, isEqualTo(authorId))
                .build()
                .render(RenderingStrategies.MYBATIS3));

        //计算价格
        int bookPrice = new BigDecimal(wordCount).multiply(bookPriceConfig.getValue()).divide(bookPriceConfig.getWordCount(),0, RoundingMode.DOWN).intValue();

        //更新小说目录表
        int indexNum = 0;
        if (book.getLastIndexId() != null) {
            indexNum = queryBookIndex(book.getLastIndexId()).getIndexNum() + 1;
        }
        BookIndex lastBookIndex = new BookIndex();
        lastBookIndex.setId(lastIndexId);
        lastBookIndex.setWordCount(wordCount);
        lastBookIndex.setIndexName(indexName);
        lastBookIndex.setIndexNum(indexNum);
        lastBookIndex.setBookId(bookId);
        lastBookIndex.setIsVip(isVip);
        lastBookIndex.setBookPrice(bookPrice);
        lastBookIndex.setCreateTime(currentDate);
        lastBookIndex.setUpdateTime(currentDate);
        bookIndexMapper.insertSelective(lastBookIndex);

        //更新小说内容表
        BookContent bookContent = new BookContent();
        bookContent.setIndexId(lastIndexId);
        bookContent.setContent(content);
        bookContentMapper.insertSelective(bookContent);


    }
"
tiffvisitor.cpp,"    void TiffReader::readTiffEntry(TiffEntryBase* object)
    {
        assert(object != 0);

        byte* p = object->start();
        assert(p >= pData_);

        if (p + 12 > pLast_) {
#ifndef SUPPRESS_WARNINGS
            EXV_ERROR << ""Entry in directory "" << groupName(object->group())
                      << ""requests access to memory beyond the data buffer. ""
                      << ""Skipping entry.\n"";
#endif
            return;
        }
        // Component already has tag
        p += 2;
        TiffType tiffType = getUShort(p, byteOrder());
        TypeId typeId = toTypeId(tiffType, object->tag(), object->group());
        long typeSize = TypeInfo::typeSize(typeId);
        if (0 == typeSize) {
#ifndef SUPPRESS_WARNINGS
            EXV_WARNING << ""Directory "" << groupName(object->group())
                        << "", entry 0x"" << std::setw(4)
                        << std::setfill('0') << std::hex << object->tag()
                        << "" has unknown Exif (TIFF) type "" << std::dec << tiffType
                        << ""; setting type size 1.\n"";
#endif
            typeSize = 1;
        }
        p += 2;
        uint32_t count = getULong(p, byteOrder());
        if (count >= 0x10000000) {
#ifndef SUPPRESS_WARNINGS
            EXV_ERROR << ""Directory "" << groupName(object->group())
                      << "", entry 0x"" << std::setw(4)
                      << std::setfill('0') << std::hex << object->tag()
                      << "" has invalid size ""
                      << std::dec << count << ""*"" << typeSize
                      << ""; skipping entry.\n"";
#endif
            return;
        }
        p += 4;
        uint32_t isize= 0; // size of Exif.Sony1.PreviewImage
        uint32_t size = typeSize * count;
        uint32_t offset = getLong(p, byteOrder());
        byte* pData = p;
        if (   size > 4
            && (   baseOffset() + offset >= size_
                || static_cast<int32_t>(baseOffset()) + offset <= 0)) {
                // #1143
                if ( object->tag() == 0x2001 && std::string(groupName(object->group())) == ""Sony1"" ) {
                 isize=size;
                } else {
#ifndef SUPPRESS_WARNINGS
            EXV_ERROR << ""Offset of directory "" << groupName(object->group())
                      << "", entry 0x"" << std::setw(4)
                      << std::setfill('0') << std::hex << object->tag()
                      << "" is out of bounds: ""
                      << ""Offset = 0x"" << std::setw(8)
                      << std::setfill('0') << std::hex << offset
                      << ""; truncating the entry\n"";
#endif
    }
                size = 0;
        }
        if (size > 4) {
            pData = const_cast<byte*>(pData_) + baseOffset() + offset;
            if (size > static_cast<uint32_t>(pLast_ - pData)) {
#ifndef SUPPRESS_WARNINGS
                EXV_ERROR << ""Upper boundary of data for ""
                          << ""directory "" << groupName(object->group())
                          << "", entry 0x"" << std::setw(4)
                          << std::setfill('0') << std::hex << object->tag()
                          << "" is out of bounds: ""
                          << ""Offset = 0x"" << std::setw(8)
                          << std::setfill('0') << std::hex << offset
                          << "", size = "" << std::dec << size
                          << "", exceeds buffer size by ""
                          // cast to make MSVC happy
                          << static_cast<uint32_t>(pData + size - pLast_)
                          << "" Bytes; truncating the entry\n"";
#endif
                size = 0;
            }
        }
        Value::AutoPtr v = Value::create(typeId);
        assert(v.get());
        if ( !isize ) {
         v->read(pData, size, byteOrder());
        } else {
         // #1143 Write a ""hollow"" buffer for the preview image
         //       Sadly: we don't know the exact location of the image in the source (it's near offset)
         //       And neither TiffReader nor TiffEntryBase have access to the BasicIo object being processed
         byte* buffer = (byte*) ::malloc(isize);
         ::memset(buffer,0,isize);
         v->read(buffer,isize, byteOrder());
         ::free(buffer);
        }

        object->setValue(v);
        object->setData(pData, size);
        object->setOffset(offset);
        object->setIdx(nextIdx(object->group()));

    } // TiffReader::readTiffEntry
","    void TiffReader::readTiffEntry(TiffEntryBase* object)
    {
        assert(object != 0);

        byte* p = object->start();
        assert(p >= pData_);

        if (p + 12 > pLast_) {
#ifndef SUPPRESS_WARNINGS
            EXV_ERROR << ""Entry in directory "" << groupName(object->group())
                      << ""requests access to memory beyond the data buffer. ""
                      << ""Skipping entry.\n"";
#endif
            return;
        }
        // Component already has tag
        p += 2;
        TiffType tiffType = getUShort(p, byteOrder());
        TypeId typeId = toTypeId(tiffType, object->tag(), object->group());
        long typeSize = TypeInfo::typeSize(typeId);
        if (0 == typeSize) {
#ifndef SUPPRESS_WARNINGS
            EXV_WARNING << ""Directory "" << groupName(object->group())
                        << "", entry 0x"" << std::setw(4)
                        << std::setfill('0') << std::hex << object->tag()
                        << "" has unknown Exif (TIFF) type "" << std::dec << tiffType
                        << ""; setting type size 1.\n"";
#endif
            typeSize = 1;
        }
        p += 2;
        uint32_t count = getULong(p, byteOrder());
        if (count >= 0x10000000) {
#ifndef SUPPRESS_WARNINGS
            EXV_ERROR << ""Directory "" << groupName(object->group())
                      << "", entry 0x"" << std::setw(4)
                      << std::setfill('0') << std::hex << object->tag()
                      << "" has invalid size ""
                      << std::dec << count << ""*"" << typeSize
                      << ""; skipping entry.\n"";
#endif
            return;
        }
        p += 4;
        uint32_t isize= 0; // size of Exif.Sony1.PreviewImage
        uint32_t size = typeSize * count;
        uint32_t offset = getLong(p, byteOrder());
        byte* pData = p;
        if (   size > 4
            && (   baseOffset() + offset >= size_
                || static_cast<int32_t>(baseOffset()) + offset <= 0)) {
                // #1143
                if ( object->tag() == 0x2001 && std::string(groupName(object->group())) == ""Sony1"" ) {
                 isize=size;
                } else {
#ifndef SUPPRESS_WARNINGS
            EXV_ERROR << ""Offset of directory "" << groupName(object->group())
                      << "", entry 0x"" << std::setw(4)
                      << std::setfill('0') << std::hex << object->tag()
                      << "" is out of bounds: ""
                      << ""Offset = 0x"" << std::setw(8)
                      << std::setfill('0') << std::hex << offset
                      << ""; truncating the entry\n"";
#endif
    }
                size = 0;
        }
        if (size > 4) {
            // setting pData to pData_ + baseOffset() + offset can result in pData pointing to invalid memory,
            // as offset can be arbitrarily large
            if ((static_cast<uintptr_t>(baseOffset()) > std::numeric_limits<uintptr_t>::max() - static_cast<uintptr_t>(offset))
             || (static_cast<uintptr_t>(baseOffset() + offset) > std::numeric_limits<uintptr_t>::max() - reinterpret_cast<uintptr_t>(pData_)))
            {
                throw Error(59);
            }
            if (pData_ + static_cast<uintptr_t>(baseOffset()) + static_cast<uintptr_t>(offset) > pLast_) {
                throw Error(58);
            }
            pData = const_cast<byte*>(pData_) + baseOffset() + offset;

     // check for size being invalid
            if (size > static_cast<uint32_t>(pLast_ - pData)) {
#ifndef SUPPRESS_WARNINGS
                EXV_ERROR << ""Upper boundary of data for ""
                          << ""directory "" << groupName(object->group())
                          << "", entry 0x"" << std::setw(4)
                          << std::setfill('0') << std::hex << object->tag()
                          << "" is out of bounds: ""
                          << ""Offset = 0x"" << std::setw(8)
                          << std::setfill('0') << std::hex << offset
                          << "", size = "" << std::dec << size
                          << "", exceeds buffer size by ""
                          // cast to make MSVC happy
                          << static_cast<uint32_t>(pData + size - pLast_)
                          << "" Bytes; truncating the entry\n"";
#endif
                size = 0;
            }
        }
        Value::AutoPtr v = Value::create(typeId);
        assert(v.get());
        if ( !isize ) {
         v->read(pData, size, byteOrder());
        } else {
         // #1143 Write a ""hollow"" buffer for the preview image
         //       Sadly: we don't know the exact location of the image in the source (it's near offset)
         //       And neither TiffReader nor TiffEntryBase have access to the BasicIo object being processed
         byte* buffer = (byte*) ::malloc(isize);
         ::memset(buffer,0,isize);
         v->read(buffer,isize, byteOrder());
         ::free(buffer);
        }

        object->setValue(v);
        object->setData(pData, size);
        object->setOffset(offset);
        object->setIdx(nextIdx(object->group()));

    } // TiffReader::readTiffEntry
"
